<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四学期课程安排]]></title>
    <url>%2F%E5%9B%9B%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92.html</url>
    <content type="text"><![CDATA[SEASON CLASS_1 CLASS_2 CLASS_3 FALL ECE269 CSE252A CSE202 WINTER ECE276A ECE141A CSE224 SPRING ECE272A ECE141B ECE250 FALL ECE271A CSE250 CSE120]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LAIOFEER公开课]]></title>
    <url>%2FLAIOFEER%E5%85%AC%E5%BC%80%E8%AF%BE.html</url>
    <content type="text"><![CDATA[Always put yourself in other people’s shoes. 换位思考 Critical thinking 任何事情并不是非黑即白 BQ question 1Tell me about yourself: Name, Education, Background Skills: Primary programming language, Projects experience, intern experience Thank you Variants: Tell me your weakness(e.g. 多任务同时处理，优先级问题) 承认自己的问题，尽量真实 Key points: How to avoid/address the same problems in the future. BQ question 2When you have different opinions from your colleagues Scenarios Communication: 1 on 1 不在公共场合批评别人; How/When/Where BQ question 3When you have limited time available to finish your project. Quality vs Speed 分情况讨论，用项目举例 Variant 1:Provide an example scenario in which you made a quick decision under pressure Variant 2: Write an email to your manager on how to explain why you missed the deadline BQ question 4What is your career plan for the next 5 years? 现在有什么，未来期待什么，怎么做？ concrete example BQ question 5How do you define a good manager? Or what do you expect from your manager? grow path BQ question 6Please tell me one of the most challenging projects you have accomplished. Why is it challenging？ Technical Human resource Operational complexity/ cost Novelty Time constraints How did you solve it? How did you evaluate the results? Scope/Impact 择高处立，就平处坐，向宽处行；立上等志，行中等事，享下等福。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>找工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福备考指北]]></title>
    <url>%2F%E6%89%98%E7%A6%8F%E5%A4%87%E8%80%83%E6%8C%87%E5%8C%97.html</url>
    <content type="text"><![CDATA[成绩说来惭愧，考了3年托福，一共四次，最终还是在临近申请前的不到一个月考出的分，而且分数也只是刚刚过百（见下图），尽管最终成绩很低，但我也有一些经验和心得与各位分享，当然，也会有一些我认为比较好的学习资源通过百度云的方式供大家学习。 学习顺序与学习时间对于理工科学生，强烈建议先学习GRE。理由有以下几点： GRE的数学对于理工科学生难度不高，不需要太多准备； GRE的verbal部分以背单词为主，这部分单词并不需要托福单词为基础，如果这部分单词搞定了，学托福难度会明显降低不少； GRE提分较快，只要刷题就会看到成效，不存在原地踏步的情况，适合初期准备。 但无论是托福和GRE我的建议都是利用暑假、寒假大块时间准备，切忌将学习英语的时间与上课/实习等杂糅在一起，这样不但英语能力不会很快见效，而且还会影响课内的学习成绩。总之用一个1-2个月的空闲时间全力学习英语之后考试一定是最高效的。 托福单词回归到托福学习。学习英语无论怎样最重要的还是背单词，单词积累的到位了，看文章听听力等自然得心应手，我比较明显的体会是在我单词掌握不扎实的时候看托福阅读都是不知所云的，仿佛在看一段加了密的文字，但在我学习GRE后，单词量得到了较大的提升，看托福阅读速度明显加快，读了一遍后内容也达到了其义自见的程度（再次说明先学GRE的好处），但不能忽视的是，很多GRE的单词书并不涵盖托福需要掌握的重点词汇，更不能轻视的是很多重要的四六级词汇，它们既不会出现在托福单词书中也不会出现在GRE单词书中，但它们的出现频率却惊人的高，这些单词一定要及时弥补！ 分享两个比较好的单词书（pdf），提取码见评论区： 托福救命800词&amp;四六级救命800词 7天搞定托福单词]]></content>
      <categories>
        <category>出国经验分享</category>
      </categories>
      <tags>
        <tag>托福</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希望所有的烦恼都能随风而去]]></title>
    <url>%2F%E7%94%9F%E6%97%A0%E6%89%80%E6%81%AF.html</url>
    <content type="text"><![CDATA[该经历的总要经历，想躲也躲不过。 该坚持的一定要坚持，坚持下去准没错。 该放手的尽快放手，省着被折磨。 最近很喜欢听周深的《无限》，可惜网易云音乐的外链无法分享。 “当风吹来，我会回来”]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献如何精读]]></title>
    <url>%2F%E6%96%87%E7%8C%AE%E5%A6%82%E4%BD%95%E7%B2%BE%E8%AF%BB.html</url>
    <content type="text"><![CDATA[第一遍：需5-10分钟快速浏览整篇论文，对其有个大概的了解。你也可以自己决定是否需要进一步阅读。该阶段分下面的几个步骤组成： 仔细阅读题目、摘要和引言； 阅读标题和小节标题，标题下的内容不必看。 阅读结论 看看参考文献，也许有你读过的论文。 在第一遍完成后，你应该可以回答以下五个问题： 类别：这篇论文是什么类型？测试类？对现有系统进行分析的？对原型系统进行描述的？ 内容：在你读过的论文中与其相关的有哪些？使用哪些理论基础来分析文章？ 正确性：结论是否有效？ 创新：该论文的主要创新是什么？ 清晰度：该论文是否条理清晰？ 回答出以上问题，你便清楚是否有必要继续阅读该论文，这也许与你的兴趣或研究领域有关，也可能是作者的结论不正确使之没必要再继续阅读。这也再次提醒你，在你写论文的时候，希望有人看你的论文，那么简明扼要的标题及摘要是非常重要的，无论是读者还是审稿人在用五分钟过一遍你的论文后，看不到文章的亮点也就对你的论文失去读下去的兴趣了。 第二遍：需1小时左右第二遍要仔细阅读论文，但忽略掉诸如证明之类的细节。 阅读过程中做好笔记记录重点，或在论文空白处标注出来。 仔细阅读论文中的数字、图表和其他插图。 尤其要注意图表： 轴标签是否正确？ 标示的结果是否有误差线？ 这些常见的错误能区分出该论文是粗制滥造的还是经过尽心做研究后的结果。 为了了解更多关于该论文的背景，记得要标记未读过的参考文献供进一步阅读。通过第二步的阅读，你应该能够掌握论文的主要内容。你也应该可以把论文的主旨及论据总结给别人。对于你感兴趣的论文，读到这个程度就可以了，但是对于那些在你研究领域内的论文来时，还远远不够。 有些情况你在读到第二步结束时仍然难以理解论文，可能的原因是主旨对你来说是全新的，还有不熟悉的术语和缩略词。也可能论文作者使用您不明白的论据或实验技术，导致大部分论文内容无法理解。除此之外，有些论文可能写得很差，也导致你无法理解该篇论文。亦或者可能是深夜，你很累了。如果是这样，你可以选择：（1）把论文放到一边，期望着在你走向事业成功的路上不需要理解它，（b）在了解了相关背景知识后，过段时间再回头读，或者（c）坚持不懈继续阅读。 第三遍：数小时要充分了解一篇论文，尤其你是审稿人时，需要进行第三步。第三步的关键是：在脑中勾勒出整篇论文，作出与作者相同的假设，重新创作。通过将这种重新创作与实际文章进行比较，您可以轻松地验证出论文的创新之处，也可以轻松找出一些不易察觉的缺陷和假设。 这一步需要读者精读论文，完成这一步读者便可验证论文中每一个假设是否成立，并且同时思考如果自己是本文作者的话会如何去体现自己的idea ，这种假设自己是作者的方法可以加深你对该论文论据及表述技巧上的理解，并且能从中学到这些技巧。在完成第三步的过程中，你应该时刻留意对于未来研究工作的新想法。 第三步是最耗费时间的，对于初学者来说可能要数小时，即便是有经验的学者也至少要一两个小时。当完成这一步后，你应该可以在脑海中重现构造论文的整个架构，同时能确定论文中哪些是好的，哪些是一般的论点。特别地，你也应该能明确指出论文中不清晰的假设、漏掉引用的相关工作以及论文中试验和分析的手段潜在的缺点。 以上内容参考知乎文章 延伸阅读： How to read a technical paper (JHU) How to read an academic paper Harvard EECS research guide]]></content>
      <categories>
        <category>远程科研</category>
      </categories>
      <tags>
        <tag>阅读文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册了新域名啦！]]></title>
    <url>%2F%E6%B3%A8%E5%86%8C%E4%BA%86%E6%96%B0%E5%9F%9F%E5%90%8D%E5%95%A6%EF%BC%81.html</url>
    <content type="text"><![CDATA[一年时间说长也长说短也短，去年的5月份我注册了"www.qianhongbo.top"这个域名，从零开始搭建自己的博客，那段时间很辛苦却也学到了不少，最近很少更新博客了，也正值之前的域名一年期限到期，注册了一个新的域名"www.qianhongbo.com"，之前没有注册.com域名的原因是不确定自己会不会坚持做下去，就没选那么贵的，选了一个便宜的，既然我已经坚持了这么久，而且做得还算可以，就注册一个更专业的.com吧！ 然而比较可惜的是注册了新域名后，站点底部的记录访问人数和人次的记录清零了，也就是一切都要从头再来，可惜！ 之后多写写博客吧！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab机器人工具箱（Robotic Toolbox）仿真双六轴机械臂对侧打磨加工]]></title>
    <url>%2FMatlab%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1%EF%BC%88Robotic%20Toolbox%EF%BC%89%E4%BB%BF%E7%9C%9F%E5%8F%8C%E5%85%AD%E8%BD%B4%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AF%B9%E4%BE%A7%E6%89%93%E7%A3%A8%E5%8A%A0%E5%B7%A5.html</url>
    <content type="text"><![CDATA[本任务为完成大三下学期机器人学课程讨论是所做实际上也是在之前做的双机仿真的基础上进行了修改。 最终结果如下： B站视频地址 使用的机器人工具箱版本为10.3.1版本 修改了工具箱自带的函数mdl_puma560，要使用代码需要在函数开头加上function p560 = mdl_puma560，结尾加上end以实现调用功能。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061%%close allclear;d = 0.2;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.8 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.8 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝前的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0-d,-0.4,0)*troty(90);%计算puma2机械臂移动到指定点，z轴指向朝后的齐次变换矩阵T3 = transl(0.3,-0.3,0)*troty(-90);T4 = transl(0+d,-0.4,0)*troty(-90);%利用ctraj函数让两个机械臂运动到指定点m1=ctraj(T1,T2,length(t)/2);n1=ctraj(T3,T4,length(t)/2);q1=p560_1.ikine6s(m1);s1=p560_2.ikine6s(n1);%移动到指定点后沿直线移动T5 = transl(0-d,0.5,0)*troty(90);%puma1沿直线移动T6 = transl(0+d,0.5,0)*troty(-90);%puma2沿直线移动 m2=ctraj(T2,T5,length(t));n2=ctraj(T4,T6,length(t));y1=p560_1.ikine6s(m2);f1=p560_2.ikine6s(n2);%重复T7 = transl(0-d,0.5,0.2)*troty(90);T8 = transl(0+d,0.5,0.2)*troty(-90); m3=ctraj(T5,T7,length(t)/2);n3=ctraj(T6,T8,length(t)/2);q2=p560_1.ikine6s(m3);s2=p560_2.ikine6s(n3);T9 = transl(0-d,-0.4,0.2)*troty(90);T10 = transl(0+d,-0.4,0.2)*troty(-90);m4=ctraj(T7,T9,length(t));n4=ctraj(T8,T10,length(t));y2=p560_1.ikine6s(m4);f2=p560_2.ikine6s(n4);%画图p560_1.plot(q1);hold on;p560_2.plot(s1);hold on;p560_1.plot(y1);hold on;p560_2.plot(f1);hold on;plot3([0 0],[-1 1],[0.2 0.2])p560_1.plot(q2);hold on;p560_2.plot(s2);hold on;p560_1.plot(y2);hold on;p560_2.plot(f2);hold on; 由于Matlab无法实现双线程编程，所以并不是同步运动，所以考虑用循环的方式来实现“同步运动”，但本质上仍然不同步。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869%%close allclear;d = 0.2;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.8 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.8 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝下的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0-d,-0.4,0)*troty(90);%计算puma2机械臂移动到指定点，z轴指向朝上的齐次变换矩阵T3 = transl(0.3,-0.3,0)*troty(-90);T4 = transl(0+d,-0.4,0)*troty(-90);%利用jtraj函数让两个机械臂运动到指定点m1=ctraj(T1,T2,length(t)/2);n1=ctraj(T3,T4,length(t)/2);q1=p560_1.ikine6s(m1);s1=p560_2.ikine6s(n1);%移动到指定点后沿直线移动T5 = transl(0-d,0.5,0)*troty(90);%puma1沿直线移动T6 = transl(0+d,0.5,0)*troty(-90);%puma2沿直线移动 m2=ctraj(T2,T5,length(t));n2=ctraj(T4,T6,length(t));y1=p560_1.ikine6s(m2);f1=p560_2.ikine6s(n2);%重复T7 = transl(0-d,0.5,0.2)*troty(90);T8 = transl(0+d,0.5,0.2)*troty(-90); m3=ctraj(T5,T7,length(t)/2);n3=ctraj(T6,T8,length(t)/2);q2=p560_1.ikine6s(m3);s2=p560_2.ikine6s(n3);T9 = transl(0-d,-0.4,0.2)*troty(90);T10 = transl(0+d,-0.4,0.2)*troty(-90);m4=ctraj(T7,T9,length(t));n4=ctraj(T8,T10,length(t));y2=p560_1.ikine6s(m4);f2=p560_2.ikine6s(n4);%画图for i=1:length(t)/2p560_1.plot(q1(i,:));hold on;p560_2.plot(s1(i,:));hold on;endfor i=1:length(t)p560_1.plot(y1(i,:));hold on;p560_2.plot(f1(i,:));hold onendplot3([0 0],[-1 1],[0.2 0.2])for i=1:length(t)/2p560_1.plot(q2(i,:));hold on;p560_2.plot(s2(i,:));hold on;endfor i=1:length(t)p560_1.plot(y2(i,:));hold on;p560_2.plot(f2(i,:));hold onend]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>Robotic Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra by 3Blue1Brown]]></title>
    <url>%2FLinear%20Algebra%20by%203Blue1Brown.html</url>
    <content type="text"><![CDATA[B站视频链接：up主 3Blue1Brown 线性变换个人认为是最核心的一个视频，也是我当时学线代的时候完全忽略掉的内容 什么是线性变换？变换后仍是直线，并且原点位置不变。也即保持网格线平行且等距离分布。 记录下两个基向量的变化，就可以表示出所有向量的变化 矩阵乘法矩阵乘法的初衷 利用上一节的知识，对基向量进行运算得到结果]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解欧拉角中的pitch,roll,yaw]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%AD%E7%9A%84roll%EF%BC%8Cpitch%EF%BC%8Cyaw.html</url>
    <content type="text"><![CDATA[欧拉角也就是绕着固定轴x,y,z旋转 在资料中关于x,y,z和三个角度的方向和对应关系定义的并不是很明确，我认为可能是这个并没有一个严格的规定，但是pitch,roll,yaw三个角度的含义定义还是很明确的。具体定义如下： pitchpitch在英文中的意思是倾斜，坠落的含义，因此就是以翅膀所在的直线为轴发生旋转 rollroll在英文中的意思是翻滚，就是绕着机身所在的那个轴 yawyaw在英文中是yaw是（火箭、飞机、宇宙飞船等）偏航的意思，也就是绕着重力方向为轴旋转]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab机器人工具箱（Robotic Toolbox）]]></title>
    <url>%2FMatlab%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    <content type="text"><![CDATA[Matlab机器人工具箱是我们在学习机器人学时候的一个非常好的工具，不但可以帮助我们计算，也可以做图形化的输出。 在此就不多谈安装问题，主要介绍各个函数的使用方法。 启动机器人工具箱1startup_rvc; 绕xyz轴的旋转变化矩阵1234rotx(30*pi/180) %用弧度rotx(30,'deg') %用角度roty(30,'deg')rotz(30,'deg') 绕xyz轴旋转的齐次变换矩阵1234trotx(30*pi/180) %用弧度trotx(30,'deg') %用角度troty(30,'deg')trotz(30,'deg') 平移齐次变换矩阵1transl([10,20,30]) 旋转变换的连续乘积1trotx(30,'deg')*troty(30,'deg')*trotz(30,'deg') rpy角旋转矩阵1234roll=10*pi/180; pitch=20*pi/180; yaw=30*pi/180;rpy2r(roll,pitch,yaw)rpy2r(roll,pitch,yaw,'zyx')rpy2r(roll,pitch,yaw,'xyz') 需要说名的是，rpy2r这个函数在不同的工具箱版本的函数并不一样，使用的角度顺序发生了改变，具体内容可以看具体版本的rpy2r.m文件。 在此附上机器人工具箱中关于各个参数option的定义，仅提供10版本 12345678910111213141516171819202122232425262728293031323334switch opt.order case &#123;'xyz', 'arm'&#125; % XYZ order if numrows(roll) == 1 R = rotx(yaw) * roty(pitch) * rotz(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = rotx(yaw(i)) * roty(pitch(i)) * rotz(roll(i)); end end case &#123;'zyx', 'vehicle'&#125; % ZYX order if numrows(roll) == 1 R = rotz(yaw) * roty(pitch) * rotx(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = rotz(yaw(i)) * roty(pitch(i)) * rotx(roll(i)); end end case &#123;'yxz', 'camera'&#125; % YXZ order if numrows(roll) == 1 R = roty(yaw) * rotx(pitch) * rotz(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = roty(yaw(i)) * rotx(pitch(i)) * rotz(roll(i)); end end endend 检验1234rotx(yaw)*roty(pitch)*rotz(roll)rotz(roll)*roty(pitch)*rotx(yaw)rotx(roll)*roty(pitch)*rotz(yaw)rotz(yaw)*roty(pitch)*rotx(roll) 结果123456%以下二者结果相同rpy2r(roll,pitch,yaw,'zyx')rotz(yaw)*roty(pitch)*rotx(roll)%以下二者结果相同rpy2r(roll,pitch,yaw,'xyz')rotx(yaw)*roty(pitch)*rotz(roll) 个人认为没必要背下来，也没必要理解，只要想用的时候能知道它是怎么算的就好。 Euler角12345%Euler角 旋转矩阵alpha=10*pi/180; beta=20*pi/180; gama=30*pi/180;eul2r(alpha,beta,gama)%检验rotz(alpha)*roty(beta)*rotz(gama) 齐次变换函数homtrans12345V=[30,40,60];T=trotx(30*pi/180);V=[V';1];homtrans(T,V)%检验T*V 绕任意轴旋转函数123%绕任意轴旋转函数theta=30*pi/180; k=[1;0;0];angvec2r(theta,k) 建立连杆坐标系123456789101112L(1)=Link('revolute','a',0,'alpha',0,'d',0);L(1).mdh=1;L(2)=Link('revolute','a',10,'alpha',pi/2,'d',0);L(2).mdh=1;L(3)=Link('revolute','a',6,'alpha',0,'d',0);L(3).mdh=1;R=SerialLink(L,'name','3RRR')%改变一些参数R.base=transl([-10 0 0]);R.tool=transl([4 0 0]);q0=[0 0 0];R.plot(q0) 让连杆坐标系运动起来1234567891011121314L(1)=Link('revolute','a',0,'alpha',0,'d',0);L(1).mdh=1;L(2)=Link('revolute','a',10,'alpha',pi/2,'d',0);L(2).mdh=1;L(3)=Link('revolute','a',6,'alpha',0,'d',0);L(3).mdh=1;R=SerialLink(L,'name','3RRR')q1=linspace(0,pi/2,100)';q2=linspace(0,pi/2,100)';q3=linspace(0,pi/2,100)';Q=[q1,q2,q3];figure(2)R.plot(Q)R.fkine(Q(end,:)) 实操任务 建立两个机器人，机器人基座的相对位置可调。（实际环境中，机器人位置可能发生变动，需要进行修改） 建立一个一条线段（一系列散点），线段的位置可调。（此线段即为机器人末端需要走的xyz轨迹点。实际环境中，轨迹位置随着工件安装位置而变换） 针对线段上的任意一个点，使某一机器人末端以某种姿态到达该点。（为xyz轨迹点加上姿态，一般的，机械臂末端z轴应当和工件表面垂直。这里只有一条线段，可指定rpy为pi/4,0,0) 针对线段上的任意一个点，使某一机器人末端以某种姿态，到达距离该点z向（末端坐标系下的z向）距离为某值的点。(此处表达的是待加工平板有一定厚度，而线段位于平板中部的情况。) 在4的基础上，使得两个机器人末端z 向正对（xy不作要求），且两个机器人末端距离可调b Matlab仿真结果图 使用的机器人工具箱版本为10.3.1版本 修改了工具箱自带的函数mdl_puma560，要使用代码需要在函数开头加上function p560 = mdl_puma560，结尾加上end以实现调用功能。 代码123456789101112131415161718192021222324252627282930313233343536close allclear;d = 0.1;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.6 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.6 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝下的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0,-0.4,d)*trotx(180);%计算puma2机械臂移动到指定点，z轴指向朝上的齐次变换矩阵T3 = transl(0.2,-0.2,-0.1);T4 = transl(0,-0.4,-d);%利用jtraj函数让两个机械臂运动到指定点q=p560_1.jtraj(T1,T2,t);s=p560_2.jtraj(T3,T4,t);%移动到指定点后沿直线移动T5 = transl(0,0.5,d)*trotx(180);%puma1沿直线移动T6 = transl(0,0.5,-d);%puma2沿直线移动 m=ctraj(T2,T5,50);n=ctraj(T4,T6,length(t));y=p560_1.ikine6s(m);f=p560_2.ikine6s(n);%画图p560_1.plot(q);hold on;p560_2.plot(s);hold on;p560_1.plot(y);hold on;p560_2.plot(f);hold on;]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>Robotic Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疫情原因宅家一个半月后出门有感]]></title>
    <url>%2F%E7%96%AB%E6%83%85%E5%8E%9F%E5%9B%A0%E5%AE%85%E5%AE%B6%E4%B8%80%E4%B8%AA%E5%8D%8A%E6%9C%88%E5%90%8E%E5%87%BA%E9%97%A8%E6%9C%89%E6%84%9F.html</url>
    <content type="text"><![CDATA[新冠病毒疫情原因，自从年前回家后，就没怎么出过门，出去两次也只是出门随便走走，没和陌生人说过话。目前疫情有较大好转，加之我头发太长，自从元旦那天在武汉剪了之后就没再动过，用理发店老板的话来讲，我这个“鸟巢”再不处理就可能要招来鸟了。 宅在家这么多天，除了偶尔的颈椎酸痛，大体上都很开心，主要是和父母沟通为主，为数不多的和别人交流也都是通过网络，感觉少了很多不必要的烦恼。自己每天做着自己认为该做的事，准备比赛也好，看看直播也罢，都让自己觉得自己还活着，没在虚度自己的光阴，和上学唯一的区别就是，我可以随意的掌控我自己的时间，至于效果怎么样，我也不得而知，但自由总是最宝贵的。 今天出门却感到有些伤感，不知道是因为在家呆的太久了对外面陌生的世界多了一份畏惧，还是在受疫情影响的社会背景下被气氛所感染，突然感觉到外面的世界并不是我曾经所认为的那么充满活力，相反，是一种死气沉沉的感觉。我对外面的一切都感到陌生，仿佛自己是一个关在监狱里5年的人，刚走出来，没有太多喜悦，反而是莫名的恐慌。 在家呆久了，每天依靠着网络，可以看到全世界各地的新闻，和天南海北的人聊天，不出门以为自己拥有了全世界。出了门才发现，原来我还是我，世界不知道还是不是之前的那个世界，但可以肯定的是我只不过是这个世界的一个过客罢了，开心就好。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020美赛有感]]></title>
    <url>%2F2020%E7%BE%8E%E8%B5%9B%E6%9C%89%E6%84%9F.html</url>
    <content type="text"><![CDATA[为了出国，提升背景为目的，我在大三报名了美赛，机缘巧合在一个留学交流群里，看到一个同学问有没有人有参加数模美赛的意向，要求是会写代码，我想着就去问问，毕竟我一个从小对数学无感，并且考了几次托福都上不了90的垃圾来说，除了写写代码还能干点什么呢？我就去说明了下自己的情况，他们考虑后也同意了，他们两个是同学，都是在经济学院，男生数学好，微积分什么的都接近满分，女生英语好，托福首考105，我了解到他们的情况之后压力还是很大的，毕竟我也只是一个懂$Matlab$语法的小白啊，数学建模这个词在我的印象里简直就像是“量子力学”一样的神秘（滑稽）。后来我们三个见面聊了聊，互相了解了下情况，我们都没有太多的数学建模基础，情况类似，之后也就没再多聊。 直到考试前，我们关于建模的事情聊得都不多，感觉我们三个都是比较内敛的人，我还算是其中比较外向的了，很多时候如果我不说话，估计群里就不会有人说话了。赶在寒假前期末考试后，我打算好好准备一下，虽然感觉毫无头绪，不知道从哪个高深的算法开始学起，但还是硬着头皮上，买了个课，每天听一听，后来就去北京学GRE了，数模什么的也就暂且搁置了，直到比赛前几周，才继续学一些知识。忘记说了，今年比较特殊的是，受疫情影响，美赛从一次改成了两次，一次是2月份，一次是3月份，我们当时想着或许3月能开学，就去搞3月的比赛（我实际上是觉得自己啥也不会，能拖几天是几天，拖，就恩拖） 然而躲得过初一却躲不过十五，3月份的比赛马上就到了，我们采用的是腾讯会议的方式线上交流。第一天早上起得很早，六点多就看赛题了，没记错的话，我3点多就醒了一次，估计是没准备太紧张了吧…拿到赛题，用词典把B题翻译了下，了解了题意，大概就是问想在海边建沙堡的话，怎么剪最好，我当时看了就觉得，这不就是开脑洞胡思乱想嘛，一个从小都没怎么去过海边的中国人，沙堡？别搞笑了，你问我怎么做汉堡好吃还差不多。 但当我用翻译软件把B题翻译了之后我才发现，或许B题是唯一一个我能理解的题目了，这就像是养龙，你说咋养就咋养，你说怎么搭沙堡就怎么搭，没有硬性规定，全靠你自己的理解，这种还算好的，毕竟只要说服了自己，就觉得没问题不是。在和两个队友商量后，也一致认为B题比较好理解，虽然暂时没有太明确的思路，但至少能靠脑子想想，编，就恩编。第一天，我们最开始思路很乱，没搞清楚应该从哪个点入手，毕竟对一个沙堡要分析的东西还是很多的，没有限定条件随便扯总不是一个事，搞数学的同学想从含水量的角度出发，我想从力的角度考虑，但奈何我的流体力学也只是学了一个皮毛，现在一个公式都想不起来的我，想从力学出发未免太难了点，搞数学的同学倒是想出了个思路，还写了不少式子，到了下午，搞数学的同学竟然已经写出了一个模型，虽然忽略了很多因素，但听起来觉得很有道理，达到了“自圆其说”的作用，于是我们就照着这个方向继续研究，提出问题，否决问题，提出方案，改正方案…就这样我慢慢觉得这个模型有搞头，至少我开始有了点思路。当晚搞数学的同学给我提出了一个难题，让我求一个函数的最小值，单求最小值不要紧，毕竟我还是上了点网课的，懂一点算法，但这函数也太复杂了，迭代套迭代，简直就是一个套娃，我完全没有思路。当晚我们还说明天要不要讨论一下F题，毕竟如果这个式子不能解决，可能这个思路就没法继续下去了。实在不行，我们就去做文字建模。。。 那晚我也没怎么睡好，因为我真的不知道这个“套娃”怎么解决，第二天早上起来我就自学了下可能能解决的办法–蒙特卡洛模拟，试着化简一下式子，再写写代码，听着两个队友在腾讯会议里讨论F题的题意，我得到了一个看起来“不错”的结果，我就在里面和他们说，如果我得到了第二问的结果，你们是觉得做F题还是B题？在我的语言诱导下，我们又开始脑洞大开建沙堡。可能是算出了个结果，有了信心，我们逐渐攻克各个难题，一起讨论，我认为我们仨合作还是很愉快的，总之就是在自圆其说的道路上越走越远233。 我们每天也不熬夜，大概10点左右就收工，早上八点集合，第三天，大部分问题也都已经想好。最后一天，该算的也算完了，我就给自己找点事做，下了个Latex（真的是作死），最后一天把我搞得死去活来，硬是坐在电脑前一天，从零入门Latex还好我有点Markdown基础，搞这个上手也比较快，我们改了又改，填了又填，最后在后半夜两点，在我们三个人一同的见证下交上了论文，4天的美赛到此结束，圆满收工。 这次美赛，收获很多，首先感谢我的两个队友，都很靠谱！我自己也算尽心尽力了，虽然基础差，但在这几天现学了不少东西，总之还是那句话，“尽吾志也而不能至者，可以无悔矣。”]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bit,Byte,K,M之间的换算问题]]></title>
    <url>%2FBit%2CByte%2CK%2CM%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E7%AE%97%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[Bit意为“位”或“比特”，是计算机运算的基础，属于二进制的范畴；Byte意为“字节”，是计算机文件大小的基本计算单位；换算： 12345671 Byte = 8 Bits 1 KB = 1024 Bytes 1 MB = 1024 KB 1 GB = 1024 MB Byte简写为B，而bit简写为b；1B=8b；一个数字与一个字母都是占1B；一个汉字占两个字节。 问题：计算机硬盘64G，每个块的大小为4K，用位示图来管理硬盘的空间，则位示图的大小为多少字节？ 16M 4M 2M 1M 解答：$$\frac{64G}{4K}=\frac{64\times1024\times1024K}{4K}次(bit)=\frac{16\times1024\times1024}{8\times1024\times1024}=2M$$]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你凭什么上北大？ 作者:贺舒婷]]></title>
    <url>%2F%E4%BD%A0%E5%87%AD%E4%BB%80%E4%B9%88%E4%B8%8A%E5%8C%97%E5%A4%A7%EF%BC%9F.html</url>
    <content type="text"><![CDATA[这是一篇陪伴我走过初中，高中的文章 在我无数次的怀疑自己，自暴自弃之后给予我力量 现在我已经来到了大学，重读此篇，来找回曾经的自己。 未名湖边的桃花开了，就在前几天。 我曾无数次梦想过，陌上开花的时候湖边折柳的人群里会有自己的身影。那个时候，我的心思和大家一样单纯而迫切，我的目光却是比你们更加迷茫和彷徨。 那年高三。 十年磨一剑，我得到的却几乎只是一块废铁。 高一那年，我真的差点把自己废成了一块废铁。上课睡觉，聊天，看漫画，吃零食，跟着后面那些男生大呼小叫，把年轻的女老师气得眼圈含泪，然后自鸣得意而洋洋之。那真是一段不堪回首的日子，像色彩斑斓的黑洞，看上去奇观异彩，鬼魅般的吸引力却在不知不觉中一点点把你拉向无敌的深渊。于是下滑，堕落，而更加难过的是明明知道自己在堕落却无力去改变。习惯的力量的确大道了让我无可奈何，于是我放弃了最后的挣扎与努力。现在想想，那只是懦弱，那只是懒惰，那只是给自己自甘堕落所找的一个看似冠冕堂皇的理由，一切是自欺欺人。 可当时没有任何人来指着我的鼻尖骂我，说你是不是就想这样破罐子破摔，就像这样玩完你的一辈子，也许他们已经放弃了我，有时候我想，然后是极其嘲讽般的不屑，不屑以及自以为是的洒脱——谁稀罕谁。其实，那个时候真的是应该有一个人，就像很多人曾经经历过的那样，指着我的鼻尖，戳着我的脊梁说，你知不知道自己在做什么，请不清楚自己想要什么，请不清楚自己的明天会是什么。 可是，在无所谓的人也会有自己的底线的。正如再深的涧谷也会有它的低谷。一切就像滑楼梯，一路上放肆张扬地笑了下来，最后终于重重的摔在了下面，头破血流。 也许，人只有在痛的时候，才会认认真真反省自己走错了哪一步吧，总要摔些跟头，才能学会绕着道走。而这条再简单不过的路，我却付出了整整一年的青春时光才真正明白。一年，365天，可以让居里夫人发现镭，可以让爱因斯坦证出E=mc2，一年可以让一个婴儿学会跌跌撞撞走向母亲的怀抱，一年可以让一段轰轰烈烈的爱情开始和终了。可是这一年，我只得到了那一句话。所幸，并不亏，也并不晚 高二分科，我选了文科。你无法想象我所在的中学有着怎样烂的文科班——本科上线只有三人，本科上线三人是个什么概念？当我现在大学同学颇为自得的告诉我他们中学的班级北大清华一走几十个的时候，我轻轻的笑了笑。我所在的文科班，是一个本科上线三人的文科班，更具有讽刺意味的是，三个人全是复读生。我就是在大家或无奈或讽刺或无谓的目光里，毅然决绝地在文科报名表上写上了自己的名字，那真是我一生中写得最好看的一次。 我只是突然间觉醒了，觉得自己的一辈子不能就那样过。时候很多人问我怎么回事，也许他们是想在我这里听到一个传奇般的浪子回头的故事，而我当时所能想到的解释就只有这一句，我只是觉得，我的一辈子不应该就这样吊儿郎当的过去。 可我还是低估了过去那一年给我带来的影响。第一次月考，我考了年级第12名，也许这是一个听上去差强人意的成绩，可是，仅有的理智还是足以提醒我，那是一个本科上线三人的文科班，如果你不能把所有的人远远甩在后面，12名和120有什么区别？ 至今我还记得那次考了第一的那个女生，是一个不见经传的女孩子，瘦瘦小小，戴副厚厚的黑边眼镜，趴伏在书桌上的身影常常有些佝偻。而这个印象的得来，是因为所有的人永远只能看到她趴在桌上的身影。她一直是班里第一个来最后一个走的人。我一直对那种学生持有一种莫名的排斥和抵触情绪，总想你们有什么了不起，不就是死读书嘛，我要是像你们这样刻苦努力早是市里第一了。事实上直到那次考试成绩出来以后我仍然对她不屑 一顾。然后，我迎来了一生中最重要的一次班会。 我不知道要用怎样的分量去感谢那个班主任，因为如果不是她的那席话，现如今的我在哪里都不一定。班会上，她说：“这次考试非常能说明问题，该考好的人都考好了。”然后她扫了我一眼，我明白她的潜台词，也就是说在她看来我属于是没有理由考好的的那一堆人里的。奇怪，我居然没有脸红。不知道是太久的堕落已经在不知不觉中磨光了原本敏感的自尊，还是下意识里仍然对她的话不置可否，我当时面无表情的迎上了她的目光。她的眼睛只是平静地扫过我那里，然后继续：“我知道有些人自以为很聪明很有才气，看不起那些认真学习刻苦努力的同学，总觉得人家是笨鸟先飞是先天不足。可是我想说，你只是懦弱！你是不敢尝试，你只是不敢像他们一样去努力去刻苦，因为你怕自己即使刻苦了也比不上他们，刻苦了也考不了第一，反而遭人耻笑，你宁可不去尝试，只是因为有失败的风险，而你甚至连这一点风险都承担不起，因为，在你心底，你对自己根本就没有把握……”后面她又说了什么我已经想不起来了，我承认当时我是完完全全懵在那儿了，因为她说的那几句话。“你只是懦弱……”当时的感觉是雷轰一样把我整个人震住了，反反复复回荡在脑子里就只有那么一句话：“你只是懦弱。” 她是正确的。 那种突然觉醒的震撼是言语无法描述的，也是我不想用文字去表达的。你只能通过结果来想象，也只需要通过借结果来想象。那晚我在日记里写，试试吧。试一试自己那样刻苦那样努力的去学上一个月会不会见效。当时我根本不敢对自己承诺什么结果，也的却承诺不起。我只是抱着一个念头，试一试。 然后迎来了一生中最戏剧性的一个月。之所以说它戏剧性，只因为就像难以想象唐僧不再啰嗦孙悟空不再好斗猪八戒不再贪吃一样，我简直不敢相信那个早晨六点早自习上课到晚上十点晚自习下课一动也不动坐在位置上安安稳稳踏踏实实的人可以是我自己。其实并没有说起来那么简单的。我去一点一点地做的时候就已经发现了：要想在几天里改变365天来形成的习惯，太难；而要想在一个月里创造出令人瞠目结舌的奇迹来，也太难。习惯成自然啊。就像那句话说的，“心思平原放马，易放难收”，野惯了的心要想一下子收回来，谈何容易？常常做着做着就忍不住了，心开始浮躁，眼神也开始飘离，好几次差一点就要放弃。只是，在那个最危险的边缘晃荡的时候我总是压一压，告诉自己，忍不住的时候，再忍一下，其实说白了也就那么一句话：忍不住的时候，再忍一下。我承认自己是一个骨子里相当傲气的人，我就是不相信我刻苦起来会不如哪个人，我就是不信我真的去做一件事情的时候会做不到，我就是不信这世上真的有什么不可能的事。I believe that nothing is impossible. 然后，我迎来了那次期待已久的期中考试，至今我仍记得考完之后的感觉。抱着书走在回家的路上，茫茫的看着车水马龙人来人往，恍惚想真的考完了吗？为什么心里空空的没有着落？那的确是我一生中最特殊的一次考试，因为它关系着我此后的方向和道路选择，风险太大，我怎么安得下心？其实。考试结果想必大家已经猜到了。我的的确确让所有的人真正瞠目结舌了一次。是的，我考了第一，全市第一。 你永远无法想象那个结果于我而言有多么重要。知道成绩是我出乎寻常的平静。那时我才明白原来激扬和呐喊的冲动到了极点只是平静。当名字出现在了成绩单的第一行时，我默默地对自己说：记住了，这世上没有什么事情是不可能的。 从此我再也没有去改变过那种态度和方法。其实所有的方法说白了都是没有方法的，只有一个词：刻苦。 我坚守着那些不是方法的方法，也坚守着我的名字在成绩单上的位置，一直到高考前的最后一次考试，我始终是第一名。但是，真正的挑战还没有开始。即使我可以牢牢占据第一名的位置，即使我可以每次都把第二名甩下几十分，我知道，北大离我还是太远，远的连在梦里都看的不真切。所有的老师都坚信我将会是学校有史以来考得最好的一个文科生，而在他们的概念里，考得最好的文科生，意味着你可以上山大，运气好点儿的话也许可以伸伸手还能够上复旦甚至人大的门槛。而我只要北大。我从来没有对任何人讲起过我的志愿——如果可以称之为志愿的话。我只想把所有的力量都积蓄起来。 高三第二学期，我们搬进了刚刚落成的教学楼。搬迁的那天，楼道里吵得很，拖桌子拉板凳的声音在走廊里不绝于耳。我一个人不言不语的跳过窗子，踏上了二楼窗外那个大大的平台。对面是操场，初雪未融，空气湿冷，光秃秃的树枝直直的刺向天空。雪天的阳光凉凉的透过睫毛洒在眼睛里。眼睛静静的看着远远的天空。我默默在心里说：“等着吧，我要你见证一个奇迹。”我知道，这世上的确没有什么不可能的事情。 我从来不知道压力达到一定程度居然可以把人的潜能激发到那种地步的。我是一个极其不安分的人，可是那段时间我表现得无比耐心沉稳，踏实得像头老黄牛。事实上无数次我都面临崩溃的边缘了。高中5本历史书我翻来覆去背了整整六遍。当你把一本书也背上6遍的时候你就知道那是什么感觉了，只是，忍不住的时候，再忍一下。坚持的确是世上最伟大的一种品质。那段时间我唯一的休息方式就是站在走廊里看远处的天空。后来发现在对面的建筑墙壁上有一行大大的红字，是学校用来激励学生的吧。我不确定。可就是那句话陪我走过了高三最后的日子——意志的力量，是决定成败的力量。我用我所有的经历和体会去实践而且证明了这句话：意志的力量，是决定成败的力量。 呼啸而过的风卷着漫天的黄沙，在那个北方的春天里，我们一个个头发蓬乱，皮肤粗糙。死寂和喧嚣交替如同美国的执政党，规律的让人怀疑冥冥之中可有双奇异而魔力无穷的手。惶然而又茫然的我们在敬畏与期待中迎来又送走了一模，二模乃至N模。每根神经都被冷酷无情的事实锤炼的坚不可摧，无论是吟惯了杨柳岸晓风残月的诗情，还是习惯了信手涂鸦的画意。在这个来去匆匆的季节里，一切敏感纤细都奢侈的如同凯撒大帝的绸衣，徒留无数次的希望在无数次的失望前撞得粉身碎骨，无数次的激扬在无数次的颓丧下摔得头破血流。每个人都比昨天更加明白理想和现实之间那道不可逾越的鸿沟，同时也比昨天更加拼命努力挣扎，试图挤过那道窄窄的独木桥，哪怕明知是徒劳。 ——会是徒劳吗？ 当这个锥心的问号在夜阑人静的时候一次次猛烈叩击起了心门，每个人都难以承受那潮涌而至的恐慌和迷惘，于是逼着自己埋进去，埋进书本，埋进试卷，埋进密不透风的黑茧里——为的是有朝一日的破茧成蝶。青黑的眼圈，浮肿的眼袋，干燥的手指，焦虑的起了水泡的嘴角。那个春天我不知道流行的是粉蓝果绿还是黛紫银灰。小镜子被悄悄收起，因为不忍见到自己憔悴的面容和黯淡的眼睛，因为怕有什么会在汪洋恣意般在干旱已久的脸上纵横开来——上帝，我是个女孩子啊！ 上帝无言。无言微笑。微笑告诉我，你，心甘情愿。是的。我心甘情愿我不悔初衷我自己选择了这条路，平坦也好崎岖也罢我得走下去。我要走下去。我会走下去。 于是所有的呐喊被咽下去，所有的豪情被收起来。我像一头二月黄牛，默默踏步，无声前行。当拼搏被拼命所取代时，香格里拉已经幻化成心中恒远而朦胧的梦想，而所有的努力也只是为了让这梦想不再“美人如花隔去端”，哪怕青冥长天，纵然绿水波澜。 踏入考场的时候我很平静，“尽吾志也而不能至者，可以无悔矣”事实上我从来没有想过自己会考入北大以外的哪所学校。与其说这是一种自信，莫如说这是一种预感。我只是想，哪怕北大只招一个名额，为什么不可能是我？这世上没有什么事情是真正不可能发生的。 考完后走在回家的路上，看着依然匆匆的人群，心里依然空无着落。眼睛因为泪雾而模糊，视野里的东西却越发清晰。这在科学上有解释，我却宁愿相信是因为一切真实的感知都要以泪水和苦痛作为代价。是的，我们总是要学会放弃一些东西，在能得到另外一些东西。如果你所在乎的东西值得你为了它而付出一切，那么所有的放弃只是分娩前的阵痛。总要有所取舍的，蝴蝶的生命之所以如此短暂，是因为它的翅膀太过精致了。有时候，放弃是为了更好的得到，关键看你想要的究竟是什么，以及为了这想要的东西你愿意付出多大的代价。上帝对每一个人都是平等的。 事实上我怀念那段日子，而且永远感激它。不只是因为在那段时间里我完成了自己的过渡与蜕变，更是因为那时的一切深深烙在了我正处于可塑期的性格中，成为这一生永远的财富。那真的是多少钱都买不来的财富。人生中再也不会有哪个时期像那时一样专一地，单纯地，坚决地，几近顽固而又饱含信仰和希冀地，心无旁骛乃至与世隔绝地，为了一个认定的目标而奋斗。当你在若干年后某个悠闲的下午，回想起自己曾经的努力和放弃，曾经的坚忍和毅力，曾经的执着和付出，曾经的汗水和泪水，那会是怎样一种感动和庆幸，怎样一种欣慰和尊重+尊敬你自己。真的，在这个过程中，请允许我重复一遍，最重要的，是你自己。我感谢父母感谢老师感谢同学感谢朋友感谢所有关心我帮助我的人，但我最感谢的，是我自己。Nothing is impossible.这是我在一点一滴的努力与尝试中得到的东西。而且我也相信，这也将会是使我终身受益的东西。在这里，我把自己最信仰的一句话送给大家：Nothing is impossible. 分享此文给所有正在奋斗拼搏的你！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华科机械学院综合测控实验]]></title>
    <url>%2F%E5%8D%8E%E7%A7%91%E6%9C%BA%E6%A2%B0%E5%AD%A6%E9%99%A2%E7%BB%BC%E5%90%88%E6%B5%8B%E6%8E%A7%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[实验一现在布置自学同学第一周的任务： 用MATLAB产生0-100hz的方波信号，可以在数字框或者滚动条上改变方波频率。 用时域过零检测方法测量你产生的方波信号，测量误差越小越好，0.2hz以内打100分，0.5hz以内95分，1hz以内90分，5hz以内85分，10hz以内80分，以上评分标准是初步设的，不满意可以提 在你产生的方波信号上添加一直流分量，比如500-1000，如何保证你的程序也正常测量。 注意初始信号值如果全为0的情况下，如何保证你的程序也正常测量。 仿真做好了，把上学期编写的采集代码替换仿真数据即完成第一次实验，第一次实验最终通过测量信号发生器的信号频率来评分。学有余力的同学可以看看实验指导书的实验六编码器模式，另外一种通过硬件测量信号频率的方法，有一定难度。]]></content>
      <categories>
        <category>华科机械学习资料分享</category>
      </categories>
      <tags>
        <tag>综合测控实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三上学期总结]]></title>
    <url>%2F%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[这是我看似很努力的一个学期，结果也还说得过去，但这些与我预想的都还差了太多，我用20分钟的时间做了一个反思，试图找出我存在的问题。 我的努力程度不够，我是一个自制力很差的人，向来如此，总是禁不住诱惑，无论是手机还是游戏，都是一沾上就会上瘾，所以这一学期我尽管花了不少时间在学习上，但相比于其他同学，可能还是不够吧，毕竟很多人可能是花费自己的全部时间去学习了。 我对某些并不感兴趣的学科没有学的认真，比如机械原理，热工基础。我并没有抱着一个为了得高分的心态，而是自认为学的够了就不学了，但很显然，这种学习程度对于达到90+以上的分数是不太可能的。 学习方法，自从上了大学，我好想对于学习方法就已经不再要求自己了，学得再也不聪明，总是以一种比较笨，低效的方式在学习，这也不是一个聪明人应该做的事情。 希望在最后的学期，我能逐渐克服这些问题，尽管GPA可能已经不会有太大的改观，但这学期对我来说尤为重要，我要考出GRE和TOEFL，我希望我能在这两项成绩的考试中证明自己，考出高分！也算不让自己的大学留下遗憾吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一切都是最好的安排]]></title>
    <url>%2F%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AE%89%E6%8E%92.html</url>
    <content type="text"><![CDATA[今天偶然想到几位曾经的高中同学，也就想起了很多高中的事，虽然大部分事情已经记得不是很清晰，也就只记得个大概。但涌上心头的不仅仅是对于回忆的伤感，更多的是一种对曾经的遗憾，毕竟当时的我还年少轻狂，对未来还有这无数的幻想，内心难免掀起波澜。 希望我能带着今天的情绪继续前行下去，不辜负家人的期待，和自己的期待，2020是决定我人生轨迹的一年，或许多年以后我回望今天，也注定会有所不同吧。 干就完了，奥利给！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机四级知识点]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[时钟分为硬件时钟和软件时钟 目态：用户态 – 一般指令 管态：系统态 – 特权指令 第三章：进程线程模型 顺序执行：顺序性；封闭性；程序结果确定性；程序结果可再现性 多道程序系统：同时处理多个具有独立功能的程序，提高利用率/ 独立性；随机性；资源共享性 程序的并发执行：并发程序相互制约；程序与计算不再一一对应；并发程序结果不可再现 多道程序系统属于各种操作系统，是一种思想（实时系统、分布系统） 并发不等于同时运行 进程 进程是正在执行的程序，包括程序，数据，进程控制块 并发性；动态性；独立性；交往性；异步性 三状态模型：就绪状态，运行状态，等待状态 就绪状态：进程分配到除CPU之外的一切资源；排成就绪队列 运行状态：就绪状态的程序获得CPU的使用权，单处理器同一时间只能有一个程序处于运行状态 等待状态/阻塞状态：进程请求输入输出、申请额外空间；不浪费CPU 创建状态，结束状态（完成、未完成） 挂起状态，激活状态（内存、外存转换） 新状态–&gt;就绪状态：就绪队列可以接纳新的进程 就绪状态–&gt;执行状态：按照算法分配；执行状态的进程称为当前进程 执行状态–&gt;就绪状态：时间片结束、优先权较低 执行状态–&gt;阻塞状态：IO请求等 阻塞状态需要先进入就绪状态再进入运行状态 PCB：进程控制块组织方式 线性方式：需要扫描所有的 索引方式：需要额外的空间 链接方式：相同状态的进程排列在一起 Unix的fork()函数父进程通过fork()创建子进程 特点：只被执行一次，返回两次结果，父进程返回的是子进程的PID，子进程中fork返回0 代码中有几个fork()就会输出2^n次 线程线程是进程的一个实体，是被系统独立调度和执行的基本单位 线程基本上不拥有系统资源，但它可以与同属于一个进程的其他线程共享所拥有的全部资源 一个线程可以创建和撤销另一个线程，多个线程之间可以并发执行，因此运行中可以呈现出异步性，因此线程同样有就绪，执行，阻塞三个状态 进程是拥有资源的基本单位 不同进程之间可以并发执行，一个进程中的多个线程也可以并发执行 QQ和音乐播放可以同时运行（多进程），QQ里可以多个人同时聊天（多线程） 线程的引入增加了并发性！ 一个程序至少有一个进程，一个进程至少有一个线程 用户级线程，内核级线程，混合级线程 调度 低级调度：内核用一定的调度算法从就绪队列选出一进程 中级调度：调度算法将等待状态的进程调至外存中 调度算法 先来先服务调度算法 FCFS：最简单，非抢占式，有利于长进程，不利于短进程。 最短作业优先算法 SPF：优先处理运行时间最短的进程，降低平均等待时间，提高吞吐量，非抢占式，对长进程不利。 最短剩余时间优先调度算法 SRT：抢占式的动态版本。 时间片轮转调度算法RR：在分时系统中，队首进程执行一个时间片，之后计时器发生一个时钟终端，并将它放到对尾，继续执行。适合于交互进程的调度。 最高优先级调度算法：为了照顾紧迫型的进程 多级反馈队列调度算法MLF：主流使用调度算法 实时系统的调度算法：速率单调调度算法，最早最终时限优先调度 进程和程序的本质区别是：进程是动态的，程序是静态的 进程和程序的其它区别是：进程是在内存，程序是在外存 第四章 并发与同步资源共享程度的三个层次：互斥、死锁、饥饿 临界资源：资源在一段时间内只允许一个进程访问和使用 进程同步机制应该遵循的原则： 空闲让进 忙则等待 有限等待：以免进入“死等” 让权等待：以免进入“忙等” 软件互斥的四种算法： 单标志算法 双标志、先检查算法 双标识、后检查算法 先修改、后检查、后修改者等待算法 进程互斥的硬件方法： TS指令 Swap指令 整型信号量： 大于0，表示系统中可用资源的数目 小于0，表示被阻塞的进程数目 等于0，系统资源已经用完，并没有因资源而被阻塞的进程 PV操作 P操作用于申请资源 V操作用于释放资源]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机四级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5讲.相关系数]]></title>
    <url>%2F%E7%AC%AC5%E8%AE%B2.%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0.html</url>
    <content type="text"><![CDATA[注意事项 非线性也会使得线性相关系数很大 离群点对相关系数的影响也很大 如果两个变量的相关系数很大，也不能说明两者相关 两个变量的相关系数结果为0，只能说明不是线性相关，但可能会有更复杂的相关关系 所以在建模时，先画出散点图！看出趋势，如果有线性关系，就可以用皮尔逊相关系数计算相关性的大小 EXCEL 跳转 ctrl + -&gt; 跳转到最后一列 ctrl + &lt;- 跳转到第一列 ctrl + shift + -&gt; 选中这一行 ctrl + shift + -&gt; + 下 选中所有的数据 ctrl + shift + -&gt; + 空格 选中所有的数据 描述性统计123456789%% 统计描述MIN = min(Test); % 每一列的最小值MAX = max(Test); % 每一列的最大值MEAN = mean(Test); % 每一列的均值MEDIAN = median(Test); %每一列的中位数SKEWNESS = skewness(Test); %每一列的偏度KURTOSIS = kurtosis(Test); %每一列的峰度STD = std(Test); % 每一列的标准差RESULT = [MIN;MAX;MEAN;MEDIAN;SKEWNESS;KURTOSIS;STD] %将这些统计量放到一个矩阵中中表示 皮尔逊相关系数计算皮尔逊相关系数是用于度量两个变量X和Y之间的相关（线性相关），其值介于-1与1之间。绝对值越大，线性相关程度越大，大于零为正相关，小于零为负相关。 1R = corrcoef(Test) % correlation coefficient 用皮尔逊相关系数进行假设检验p值判断法： p&lt;0.05，说明在95%的置信水平上拒绝原假设 p&gt;0.05，说明在95%的置信水平上无法拒绝原假设 检验数据是否是正态分布 JB检验（大样本 n&gt;30） Shapiro-Wilk检验（小样本 3&lt;n&lt;50） Q-Q图（样本数量极大） 123456789x = normrnd(2,3,100,1); % 生成100*1的随机向量，每个元素是均值为2，标准差为3的正态分布skewness(x) %偏度kurtosis(x) %峰度% 检验第一列数据是否为正态分布[h,p] = jbtest(Test(:,1),0.05)% Q-Q图qqplot(Test(:,1)) 斯皮尔曼相关系数123456789X = [3 8 4 7 2]' % 一定要是列向量Y = [5 10 9 10 6]'coeff = corr(X , Y , 'type' , 'Spearman')% 等价于：RX = [2 5 3 4 1]RY = [1 4.5 3 4.5 2]R = corrcoef(RX,RY)[R,P]=corr(Test, 'type' , 'Spearman')]]></content>
      <categories>
        <category>数模美赛</category>
      </categories>
      <tags>
        <tag>数模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】外部中断实验]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[外部中断概述 STM32的每个IO都可以作为外部中断输入。 STM32的中断控制器支持19个外部中断/事件请求： 线0~15：对应外部IO口的输入中断。 线16：连接到PVD输出。 线17：连接到RTC闹钟事件。 线18：连接到USB唤醒事件。 每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位。 从上面可以看出，STM32供IO使用的中断线只有16个，但是STM32F10x系列的IO口多达上百个，那么中断线怎么跟io口对应呢？ GPIOx.0映射到EXTI0 GPIOx.1映射到EXTI1 … GPIOx.15映射到EXTI15 IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数 从表中可以看出，外部中断线59分配一个中断向量，共用一个服务函数，外部中断线1015分配一个中断向量，共用一个中断服务函数。 外部中断常用库函数1234567891011121314//exti.c文件void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);//设置IO口与中断线的映射关系exp: GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct); //初始化中断线：触发方式等ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);//判断中断线中断状态，是否发生void EXTI_ClearITPendingBit(uint32_t EXTI_Line);//清除中断线上的中断标志位 实际代码12345678910111213141516171819202122232425262728293031323334353637383940#include "exti.h"#include "stm32f10x.h"#include "key.h"#include "delay.h"#include "led.h"void EXTIX_Init(void)&#123; EXTI_InitTypeDef EXTI_InitStruct; NVIC_InitTypeDef NVIC_InitStruct; KEY_Init(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); EXTI_InitStruct.EXTI_Line = EXTI_Line4; EXTI_InitStruct.EXTI_LineCmd = ENABLE; EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStruct); NVIC_InitStruct.NVIC_IRQChannel = EXTI4_IRQn; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2; NVIC_Init(&amp;NVIC_InitStruct);&#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10); if(KEY0 == 0)&#123; LED0 = !LED0; LED1 = !LED1; &#125; //手动清除中断标志位 EXTI_ClearITPendingBit(EXTI_Line4);&#125; 1234567891011121314151617181920212223//main.c文件#include "stm32f10x.h"#include "led.h"#include "beep.h"#include "key.h"#include "sys.h"#include "delay.h"#include "exti.h"#include "usart.h"int main()&#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 EXTIX_Init(); LED0 = 0; //先点亮红灯 while(1) &#123; printf("OK\r\n"); &#125; &#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】串口通信基本原理]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[处理器与外部设备通信的两种方式 并行通信 传输原理：数据各个位同时传输。 优点：速度快 缺点：占用引脚资源多 串行通信 传输原理：数据按位顺序传输。 优点：占用引脚资源少 缺点：速度相对较慢 串行通信分类按照数据传送方向，分为： 单工：数据传输只支持数据在一个方向上传输 半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 串行通信的通信方式 同步通信：带时钟同步信号传输。-SPI，IIC通信接口 异步通信：不带时钟同步信号。-UART(通用异步收发器),单总线（必须约定波特率，按照相同的速度发送和读取） 常见的串行通信接口 STM32的串口通信接口 UART:通用异步收发器 USART:通用同步异步收发器 大容量STM32F10x系列芯片，包含3个USART和2个UART UART异步通信方式引脚连接方法 RXD:数据输入引脚。数据接受。 TXD:数据发送引脚。数据发送。 UART异步通信方式特点 全双工异步通信。 分数波特率发生器系统，提供精确的波特率。 发送和接受共用的可编程波特率，最高可达4.5Mbits/s 可编程的数据字长度（8位或者9位）； 可配置的停止位（支持1或者2位停止位）； 可配置的使用DMA多缓冲器通信。 单独的发送器和接收器使能位。 检测标志：① 接受缓冲器 ②发送缓冲器空 ③传输结束标志 多个带标志的中断源。触发中断。 其他：校验控制，四个错误检测标志。 STM32串口异步通信需要定义的参数 起始位，通信双方约定从空闲位开始 数据位（8位或者9位），第九位就是奇偶校验位 奇偶校验位（第9位），偶校验：使1的数量为偶数；奇校验：使1的数量为奇数 停止位（1,15,2位） 波特率设置 常用的串口相关寄存器 USART_SR状态寄存器 USART_DR数据寄存器 USART_BRR波特率寄存器 波特率计算方法 串口操作相关库函数1234567891011void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能void USART_Cmd();//使能串口void USART_ITConfig();//使能相关中断void USART_SendData();//发送数据到串口，DRuint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据FlagStatus USART_GetFlagStatus();//获取状态标志位void USART_ClearFlag();//清除状态标志位ITStatus USART_GetITStatus();//获取中断状态标志位void USART_ClearITPendingBit();//清除中断状态标志位 串口配置的一般步骤 串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd(); 串口复位:USART_DeInit(); 这一步不是必须的 GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP 串口参数初始化：USART_Init(); 开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）NVIC_Init();``USART_ITConfig(); 使能串口:USART_Cmd(); 编写中断处理函数：USARTx_IRQHandler(); 串口数据收发：void USART_SendData();//发送数据到串口，DR, uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据 串口传输状态获取：FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG); void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】NVIC中断优先级管理]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91NVIC%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[NVIC中断介绍 CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。 STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。 STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。 STM32F103系列上面，又只有60个可屏蔽中断（在107系列才有68个） 中断管理方法首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。 分组配置是在寄存器SCB-&gt;AIRCR中配置： 抢占优先级 &amp; 响应优先级区别 高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。 抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。 抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。 如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行； 举例假定设置中断优先级组为2，然后设置中断3(RTC中断)的抢占优先级为2，响应优先级为1。 中断6（外部中断0）的抢占优先级为3，响应优先级为0。中断7（外部中断1）的抢占优先级为2，响应优先级为0。 那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6。 特别说明一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。 中断优先级分组函数1234567void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)&#123; assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup)); SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;&#125;//比如：NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 中断设置相关寄存器123456__IO uint8_t IP[240]; //中断优先级控制的寄存器组__IO uint32_t ISER[8]; //中断使能寄存器组__IO uint32_t ICER[8]; //中断失能寄存器组__IO uint32_t ISPR[8]; //中断挂起寄存器组__IO uint32_t ICPR[8]; //中断解挂寄存器组__IO uint32_t IABR[8]; //中断激活标志位寄存器组 MDK中NVIC寄存器结构体12345678910111213141516typedef struct&#123; __IO uint32_t ISER[8]; uint32_t RESERVED0[24]; __IO uint32_t ICER[8]; uint32_t RSERVED1[24]; __IO uint32_t ISPR[8]; uint32_t RESERVED2[24]; __IO uint32_t ICPR[8]; uint32_t RESERVED3[24]; __IO uint32_t IABR[8]; uint32_t RESERVED4[56]; __IO uint8_t IP[240]; uint32_t RESERVED5[644]; __O uint32_t STIR; &#125; NVIC_Type; 对于每个中断怎么设置优先级中断优先级控制的寄存器组：IP[240] 全称是：Interrupt Priority Registers 240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F10x系列一共60个可屏蔽中断，使用IP[59]~IP[0]。 每个IP寄存器的高4位用来设置抢占和响应优先级（根据分组），低4位没有用到。 void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 中断使能寄存器组：ISER[8] 作用：用来使能中断 32位寄存器，每个位控制一个中断的使能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ISER[0]和ISER[1]。 ISER[0]的bit0-bit31分别对应中断0-31。ISER[1]的bit0-27对应中断32~59； void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 中断失能寄存器组：ICER[8] 作用：只读，通过它可以知道当前在执行的中断是哪一个 32位寄存器，每个位控制一个中断的失能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ICER[0]和ICER[1]。 ICER[0]的bit0~bit31分别对应中断0~31。ICER[1]的bit0~27对应中断32~59； 配置方法跟ISER一样static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn) 中断挂起控制寄存器组：ISPR[8] 作用：用来挂起中断 中断解挂控制寄存器组：ICPR[8] 作用：用来解挂中断 123static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)；static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)；static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn) 中断激活标志位寄存器组：IABR [8] 作用：只读，通过它可以知道当前在执行的中断是哪一个 如果对应位为1，说明该中断正在执行。 static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn) 中断参数初始化函数12345678910111213141516void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);typedef struct&#123; uint8_t NVIC_IRQChannel; //设置中断通道 uint8_t NVIC_IRQChannelPreemptionPriority;//设置响应优先级 uint8_t NVIC_IRQChannelSubPriority; //设置抢占优先级 FunctionalState NVIC_IRQChannelCmd; //使能/使能&#125; NVIC_InitTypeDef;NVIC_InitTypeDef NVIC_InitStructure;NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级为1NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;// 子优先级位2NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能NVIC_Init(&amp;NVIC_InitStructure); //根据上面指定的参数初始化NVIC寄存器 中断优先级设置步骤 系统运行后先设置中断优先级分组。调用函数：void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);整个系统执行过程中，只设置一次中断分组。 针对每个中断，设置对应的抢占优先级和响应优先级：void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】端口复用]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8.html</url>
    <content type="text"><![CDATA[什么是端口复用STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。也就是说，一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用。 例如串口1 的发送接收引脚是PA9,PA10，当我们把PA9,PA10不用作GPIO，而用做复用功能串口1的发送接收引脚的时候，叫端口复用。 端口复用配置过程以PA9,PA10配置为串口1为例 GPIO端口时钟使能。RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 复用外设时钟使能。比如你要将端口PA9,PA10复用为串口，所以要使能串口时钟。RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); 端口模式配置。 GPIO_Init（）函数。查表：《STM32中文参考手册V10》P110的表格“8.1.11外设的GPIO配置” 12345678910111213RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//①IO时钟使能RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);//②外设时钟使能//③初始化IO为对应的模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9//复用推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 PA.10 浮空输入GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入GPIO_Init(GPIOA, &amp;GPIO_InitStructure);]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】SysTick定时器]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91SysTick%E5%AE%9A%E6%97%B6%E5%99%A8.html</url>
    <content type="text"><![CDATA[Systick定时器是什么 Systick定时器，是一个简单的定时器，对于CM3,CM4内核芯片，都有Systick定时器。 Systick定时器常用来做延时，或者实时系统的心跳时钟。这样可以节省MCU资源，不用浪费一个定时器。比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟。 Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。 SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15） Systick中断的优先级也可以设置。 Systick相关寄存器 CTRL SysTick 控制和状态寄存器 LOAD SysTick 自动重装载除值寄存器对于STM32，外部时钟源是 HCLK(AHB总线时钟）的1/8内核时钟是 HCLK时钟,配置函数：SysTick_CLKSourceConfig() VAL SysTick 当前值寄存器 CALIB SysTick 校准值寄存器 Systick库函数固件库中的Systick相关函数： 1234567SysTick_CLKSourceConfig() //Systick时钟源选择 misc.c文件中SysTick_Config(uint32_t ticks) //初始化systick,时钟为HCLK,并开启中断//core_cm3.h/core_cm4.h文件中//Systick中断服务函数：void SysTick_Handler(void); 123456789101112131415//SysTick_CLKSourceConfig函数void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)&#123; /* Check the parameters */ assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource)); if (SysTick_CLKSource == SysTick_CLKSource_HCLK) &#123; SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK; &#125; else &#123; SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8; &#125;&#125; 123456789101112131415//SysTick_CLKSourceConfig函数static __INLINE uint32_t SysTick_Config(uint32_t ticks)&#123; if (ticks &gt; SysTick_LOAD_RELOAD_Msk) return (1); /* Reload value impossible */ /* set reload register */ SysTick-&gt;LOAD = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1; /* set Priority for Cortex-M0 System Interrupts */ NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); SysTick-&gt;VAL = 0; /* Load the SysTick Counter Value */ SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable SysTick IRQ and SysTick Timer */ return (0); /* Function successful */&#125; 12345678910111213141516171819202122232425//用中断的方式实现delay延时static __IO uint32_t TimingDelay;void Delay(__IO uint32_t nTime)&#123; TimingDelay = nTime; while(TimingDelay != 0);&#125;void SysTick_Handler(void)&#123; if (TimingDelay != 0x00) &#123; TimingDelay--; &#125;&#125; int main(void) &#123; … if (SysTick_Config(SystemCoreClock / 1000)) //systick时钟为HCLK，中断时间间隔1ms &#123; while (1); &#125; while(1) &#123; Delay(200);//2ms … &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void delay_init()&#123;#if SYSTEM_SUPPORT_OS //如果需要支持OS. u32 reload;#endif SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SystemCoreClock/8000000; //为系统时钟的1/8 #if SYSTEM_SUPPORT_OS //如果需要支持OS. reload=SystemCoreClock/8000000; //每秒钟的计数次数 单位为K reload*=1000000/delay_ostickspersec; //根据delay_ostickspersec设定溢出时间 //reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右 fac_ms=1000/delay_ostickspersec; //代表OS可以延时的最少单位 SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk; //开启SYSTICK中断 SysTick-&gt;LOAD=reload; //每1/delay_ostickspersec秒中断一次 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk; //开启SYSTICK #else fac_ms=(u16)fac_us*1000; //非OS下,代表每个ms需要的systick时钟数 #endif&#125; #if SYSTEM_SUPPORT_OS //如果需要支持OS.//延时nus//nus为要延时的us数. void delay_us(u32 nus)&#123; u32 ticks; u32 told,tnow,tcnt=0; u32 reload=SysTick-&gt;LOAD; //LOAD的值 ticks=nus*fac_us; //需要的节拍数 tcnt=0; delay_osschedlock(); //阻止OS调度，防止打断us延时 told=SysTick-&gt;VAL; //刚进入时的计数器值 while(1) &#123; tnow=SysTick-&gt;VAL; if(tnow!=told) &#123; if(tnow&lt;told)tcnt+=told-tnow; //这里注意一下SYSTICK是一个递减的计数器就可以了. else tcnt+=reload-tnow+told; told=tnow; if(tcnt&gt;=ticks)break; //时间超过/等于要延迟的时间,则退出. &#125; &#125;; delay_osschedunlock(); //恢复OS调度 &#125;//延时nms//nms:要延时的ms数void delay_ms(u16 nms)&#123; if(delay_osrunning&amp;&amp;delay_osintnesting==0) //如果OS已经在跑了,并且不是在中断里面(中断里面不能任务调度) &#123; if(nms&gt;=fac_ms) //延时的时间大于OS的最少时间周期 &#123; delay_ostimedly(nms/fac_ms); //OS延时 &#125; nms%=fac_ms; //OS已经无法提供这么小的延时了,采用普通方式延时 &#125; delay_us((u32)(nms*1000)); //普通方式延时 &#125;#else //不用OS时//延时nus//nus为要延时的us数. void delay_us(u32 nus)&#123; u32 temp; SysTick-&gt;LOAD=nus*fac_us; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 do &#123; temp=SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 &#125;//延时nms//注意nms的范围//SysTick-&gt;LOAD为24位寄存器,所以,最大延时为://nms&lt;=0xffffff*8*1000/SYSCLK//SYSCLK单位为Hz,nms单位为ms//对72M条件下,nms&lt;=1864 void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 do &#123; temp=SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 &#125; #endif]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】STM32时钟系统和时钟系统初始化函数]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91STM32%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[时钟系统知识总结 STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。 HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。 HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。 LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。WDG LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。 系统时钟SYSCLK可来源于三个时钟源： HSI振荡器时钟 HSE振荡器时钟 PLL时钟 STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。 任何一个外设在使用之前，必须首先使能其相应的时钟。 几个重要的时钟： SYSCLK(系统时钟) : AHB总线时钟 APB1总线时钟(低速): 速度最高36MHz APB2总线时钟(高速): 速度最高72MHz PLL时钟 RCC相关配置寄存器12345678910111213typedef struct&#123; __IO uint32_t CR; //HSI,HSE,CSS,PLL等的使能和就绪标志位 __IO uint32_t CFGR; //PLL等的时钟源选择，分频系数设定 __IO uint32_t CIR; // 清除/使能 时钟就绪中断 __IO uint32_t APB2RSTR; //APB2线上外设复位寄存器 __IO uint32_t APB1RSTR; //APB1线上外设复位寄存器 __IO uint32_t AHBENR; //DMA，SDIO等时钟使能 __IO uint32_t APB2ENR; //APB2线上外设时钟使能 __IO uint32_t APB1ENR; //APB1线上外设时钟使能 __IO uint32_t BDCR; //备份域控制寄存器 __IO uint32_t CSR; //控制状态寄存器&#125; RCC_TypeDef; SystemInit源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void SystemInit (void)&#123; /* Reset the RCC clock configuration to the default reset state(for debug purpose) */ /* Set HSION bit */ RCC-&gt;CR |= (uint32_t)0x00000001; //或等于，也就是将最低位设置为1，其它位不变 //将最低位设置为1，HSION：内部高速时钟使能 /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */#ifndef STM32F10X_CL RCC-&gt;CFGR &amp;= (uint32_t)0xF8FF0000; //并未定义STM32F10X_CL#else RCC-&gt;CFGR &amp;= (uint32_t)0xF0FF0000; //将0-15位置零，将24-27置零 //查表可知，低四位为零目的是使SW, HPRE, PPRE1, PPRE2, ADCPRE, MCO几个寄存器复位。#endif /* STM32F10X_CL */ /* Reset HSEON, CSSON and PLLON bits */ RCC-&gt;CR &amp;= (uint32_t)0xFEF6FFFF; //将16-19位与0110运算，也就是16,19位置零 //将24-27位与1110运算，也就是24位置零 //查表可知，目的是将HSEON, CSSON and PLLON几个寄存器复位 /* Reset HSEBYP bit */ RCC-&gt;CR &amp;= (uint32_t)0xFFFBFFFF; //16-19位为B，也就是1011 //与运算，也就是将18位置零 //查表可知，目的是将HSEBYP复位 /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */ RCC-&gt;CFGR &amp;= (uint32_t)0xFF80FFFF; //16-19位为与运算0000 //20-23位为与运算1000 //也就是将16-19位置零，20-23位置零 //查表可知，目的是将PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE 复位#ifdef STM32F10X_CL //并未定义 /* Reset PLL2ON and PLL3ON bits */ RCC-&gt;CR &amp;= (uint32_t)0xEBFFFFFF; /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x00FF0000; /* Reset CFGR2 register */ RCC-&gt;CFGR2 = 0x00000000;#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL) /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x009F0000; /* Reset CFGR2 register */ RCC-&gt;CFGR2 = 0x00000000; #else /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x009F0000;#endif /* STM32F10X_CL */ #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL) //定义了STM32F10X_HD #ifdef DATA_IN_ExtSRAM SystemInit_ExtMemCtl(); #endif /* DATA_IN_ExtSRAM */#endif /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */ /* Configure the Flash Latency cycles and enable prefetch buffer */ SetSysClock();#ifdef VECT_TAB_SRAM SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */#else SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */#endif &#125; 12345678910111213141516static void SetSysClock(void)&#123;#ifdef SYSCLK_FREQ_HSE SetSysClockToHSE();#elif defined SYSCLK_FREQ_24MHz SetSysClockTo24();#elif defined SYSCLK_FREQ_36MHz SetSysClockTo36();#elif defined SYSCLK_FREQ_48MHz SetSysClockTo48();#elif defined SYSCLK_FREQ_56MHz SetSysClockTo56(); #elif defined SYSCLK_FREQ_72MHz SetSysClockTo72();#endif&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495static void SetSysClockTo72(void)&#123; __IO uint32_t StartUpCounter = 0, HSEStatus = 0; /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/ /* Enable HSE */ RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); /* Wait till HSE is ready and if Time out is reached exit */ do &#123; HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY; StartUpCounter++; &#125; while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT)); if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET) &#123; HSEStatus = (uint32_t)0x01; &#125; else &#123; HSEStatus = (uint32_t)0x00; &#125; if (HSEStatus == (uint32_t)0x01) &#123; /* Enable Prefetch Buffer */ FLASH-&gt;ACR |= FLASH_ACR_PRFTBE; /* Flash 2 wait state */ FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY); FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_2; /* HCLK = SYSCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1; /* PCLK2 = HCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1; /* PCLK1 = HCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;#ifdef STM32F10X_CL /* Configure PLLs ------------------------------------------------------*/ /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */ /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */ RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL | RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC); RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 | RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5); /* Enable PLL2 */ RCC-&gt;CR |= RCC_CR_PLL2ON; /* Wait till PLL2 is ready */ while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0) &#123; &#125; /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL); RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLMULL9); #else /* PLL configuration: PLLCLK = HSE * 9 = 72 MHz */ RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL)); RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);#endif /* STM32F10X_CL */ /* Enable PLL */ RCC-&gt;CR |= RCC_CR_PLLON; /* Wait till PLL is ready */ while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0) &#123; &#125; /* Select PLL as system clock source */ RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL; /* Wait till PLL is used as system clock source */ while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) &#123; &#125; &#125; else &#123; /* If HSE fails to start-up, the application will have wrong clock configuration. User can add here some code to deal with this error */ &#125;&#125;#endif]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】struct和typedef struct]]></title>
    <url>%2F%E3%80%90C%E3%80%91struct%E5%92%8Ctypedef%20struct.html</url>
    <content type="text"><![CDATA[首先注意在C和C++里不同 在C中定义一个结构体类型要用typedef: 1234typedef struct Student &#123; int a; &#125;Stu; 于是在声明变量的时候就可：Stu stu1 (如果没有typedef就必须用struct Student stu1;来声明) 这里的Stu实际上就是struct Student的别名。Stu==struct Student 另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;） 1234typedef struct &#123; int a; &#125;Stu; 但在c++里很简单，直接 1234struct Student &#123; int a; &#125;; 于是就定义了结构体类型Student，声明变量时直接Student stu2 其次 在c++中如果用typedef的话，又会造成区别： 1234struct Student&#123; int a;&#125;stu1; //stu1是一个变量 1234typedef struct Student2 &#123; int a; &#125;stu2; //stu2是一个结构体类型=struct Student 使用时可以直接访问stu1.a， 但是stu2则必须先stu2 s2;然后s2.a=10; 最后 typedef struct和struct的区别： 12345678typedef struct tagMyStruct &#123; int iNum; long lLength; &#125; MyStruct;//上面的tagMyStruct是标识符，//MyStruct是变量类型（相当于（int,char等）） 这语句实际上完成两个操作： 定义一个新的结构类型 12345struct tagMyStruct &#123; int iNum; long lLength; &#125;; typedef为这个新的结构起了一个名字，叫MyStruct 1 typedef struct tagMyStruct MyStruct; 12345typedef struct tagMyStruct &#123; int iNum; long lLength; &#125; MyStruct; 在C中，这个申明后申请结构变量的方法有两种： struct tagMyStruct 变量名 MyStruct 变量名 在c++中可以有 struct tagMyStruct 变量名 MyStruct 变量名 tagMyStruct 变量名]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】从GPIO_Init引发的关于C的研究]]></title>
    <url>%2F%E3%80%90C%E3%80%91%E4%BB%8EGPIO_Init%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EC%E7%9A%84%E7%A0%94%E7%A9%B6.html</url>
    <content type="text"><![CDATA[在我看下面这段代码对GPIO_Init有一些不理解 123456789101112void BEEP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //声明变量 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //不理解 GPIO_ResetBits(GPIOB,GPIO_Pin_8);&#125; 首先看一下GPIO_Init的语法 1void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct); 我产生了几个疑问： GPIO_TypeDef* GPIOx是什么意思？ 为什么&amp;GPIO_InitStructure要用指针类型？ 为什么GPIOB不用使用指针类型？ 1234567//这里定义了一个结构体typedef struct&#123; u16 GPIO_Pin; GPIOSpeed_TypeDef GPIO_Speed; GPIOMode_TypeDef GPIO_Mode;&#125;GPIO_InitTypeDef; //代码里用它来声明变量 怎么理解呢？int 是 类型， i 是变量GPIO_InitTypeDef GPIO_InitStructure;同样，GPIO_InitTypeDef 是类型，GPIO_InitStructure 是变量！ C语言里面没有这种GPIO_InitTypeDef 类型 ，所以要自己 通过 typedef 来定义这种类型。 引用自一个知乎问题，链接 一般int* p表示p类型是一个int型指针，int *p表示p是一个指针，指向的类型是int。 也就是GPIO_TypeDef* GPIOx等同于GPIO_TypeDef *GPIOx，而且我之前对于init *p也有误解，我以为这是在声明一个init常量，我当时误认*已经把地址取值了，实则是造成了误会，它是定义了一个指向init类型的指针变量，也就是p，所以从这点考虑，init* p或许表意更清楚一点！ 终于搞懂了！！！ 第二个问题也就好解释了，因为GPIO_Init就是要求输入两个指针变量 第三个问题 GPIOB本身就是一个指针类型！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】按键输入实验]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[GPIO操作复习 读取IO口输入电平调用库函数为 1uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 读取IO口输入电平操作寄存器为 1GPIOx_IDR:端口输入寄存器 使用位带操作读取IO口输入电平： 12PEin(4) //读取GPIOE.4口电平PEin(n) //读取GPIOE.n口电平 步骤 使能按键对应IO口时钟。调用函数：RCC_APB2PeriphClockCmd() 初始化IO模式：上拉/下拉输入。调用函数：GPIO_Init() 扫描IO口电平（库函数/寄存器/位操作） 硬件连接 所以需要打开PA,PE的时钟，并打开PA0; PE2,3,4; 而且，对于KEY0，一端连接地，另一端连接PE4的IO口，KEY1，KEY2同理，所以当案件按下的时候，IO口坚持得到低电平。WK_UP正好相反。 按键扫描思路扫描的两种类型 支持连续监测，比如遥控器选台的前进按钮，一直按会一直跳台 不支持连续监测，比如遥控器的关机/开机按钮，一直按但只会执行一次操作 引入C语言关键字：static Static申明的局部变量，存储在静态存储区。 它在函数调用结束之后，不会被释放。它的值会一直保留下来。 所以可以说static申明的局部变量，具有记忆功能。 1234567891011121314151617//利用两个函数说明问题//1. 用intint getValue(void)&#123; int flag=0; flag++; return flag;&#125;//2. 用staticint getValue(void)&#123; static int flag=0; /*初始化函数只会在第一次使用中运行，第二次调用getvalue函数就会直接跳到下面的语句，不会再次执行。*/ flag++; return flag;&#125; 实际代码操作尝试！第一次123456789101112131415161718192021222324252627282930/*demo1，将循环体放在两个getvalue中*/#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a; for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; return a; &#125;&#125;int getvalue2(void)&#123; for(int i = 10; i &gt; 0; i--)&#123; static int b = 0; b++; return b; &#125;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译报warning: control reaches end of non-void function 编译结果为“1,1”，结果不对！ 分析原因: C语言必须要有返回值，例如return 0，或者return a等等 我将两个getvalue函数中的return写在了循环体里，并不会返回！ 至于为什么出现了错误的结果，根据debug发现，并没有执行循环，而是只执行了一次，原因在于第一次就return了！ 第二次进行如下修改： 123456789101112131415161718192021222324252627282930//将return修改到循环体之外#include &lt;stdio.h&gt;int getvalue1(void)&#123; for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; &#125; return a; &#125;int getvalue2(void)&#123; for(int i = 10; i &gt; 0; i--) &#123; static int b = 0; b++; &#125; return b;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译出现错误：identifier &quot;a&quot; is undefined；identifier &quot;b&quot; is undefined； 原因：未定义变量a和b！ 我的int a,static int b,都是在循环体里定义的，依然在函数中生效 第三次继续修改！ 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a; //添加定义 for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; &#125; return a; &#125;int getvalue2(void)&#123; int b; //添加定义 for(int i = 10; i &gt; 0; i--) &#123; static int b = 0; b++; &#125; return b;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译未出现错误，但结果为“0,1”，结果不对 分析原因：暂时未知，怀疑是循环体执行的`b`并没有并没有返回出来 第四次继续修改！ 12345678910111213141516171819202122232425//将循环体放在main中，而getvalue函数不执行循环功能#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a = 0; a++; return a;&#125;int getvalue2(void)&#123; static int b = 0; b++; return b;&#125;int main()&#123; int c,d; for(int i = 10; i &gt;0; i--)&#123; int c = getvalue1(); int d = getvalue2(); &#125; printf("%d, %d", c, d); getchar(); return 0;&#125; 结果仍然不对…得到的结果为：7349584, 0 原因重复定义？一个变量只能被定义一次！ 一个函数外面对变量进行了定义，循环体里就不用定义了。static可能是个例外… 第五次最终修改版本： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a = 0; a++; return a;&#125;int getvalue2(void)&#123; static int b = 0; b++; return b;&#125;int main()&#123; int a,b; for(int i = 10; i &gt;0; i--)&#123; a = getvalue1(); b = getvalue2(); &#125; printf("%d, %d", a, b); getchar(); return 0;&#125; 结果正确，得到“1,10”!! 总结问题在于C语言基础不牢，关于变量定义范围还需要进行复习！！ 两种扫描的具体思路1234567891011121314//支持连续按//代码比较好理解u8 KEY_Scan(void) &#123; if(KEY按下） &#123; delay_ms(10)；//延时10-20ms，防抖。 if(KEY确实按下) &#123; return KEY_Value； &#125; return 无效值； &#125; &#125; 12345678910111213141516//不支持连续按，按一次就是一次//代码稍显复杂，比较巧妙u8 KEY_Scan(void) &#123; static u8 key_up=1; //引入局部变量key_up if（key_up &amp;&amp; KEY按下） &#123; delay_ms(10); //延时，防抖 key_up=0; //标记这次key已经按下 if(KEY确实按下) &#123; return KEY_VALUE; &#125; &#125;else if(KEY没有按下) key_up=1; return 没有按下 &#125; 1234567891011121314151617//按键扫描二合一！//函数需要给一个值u8 KEY_Scan(u8 mode) &#123; static u8 key_up=1; if(mode==1) key_up=1;//支持连续按 if（key_up &amp;&amp; KEY按下） &#123; delay_ms(10);//延时，防抖 key_up=0;//标记这次key已经按下 if(KEY确实按下) &#123; return KEY_VALUE; &#125; &#125;else if(KEY没有按下) key_up=1; return 没有按下 &#125; 实际代码123456789101112131415161718//key.h#ifndef __KEY_H#define __KEY_H #define KEY0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4) //读取按键0#define KEY1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3) //读取按键1#define KEY2 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2) //读取按键2 #define WK_UP GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)//读取按键3(WK_UP) #define KEY0_PRES 1 //KEY0按下#define KEY1_PRES 2 //KEY1按下#define KEY2_PRES 3 //KEY2按下#define WKUP_PRES 4 //KEY_UP按下(即WK_UP/KEY_UP)void KEY_Init(void); //IO初始化u8 KEY_Scan(u8); //按键扫描函数#endif 1234567891011121314151617181920212223242526272829303132333435363738394041//key.c#include "stm32f10x.h"#include "key.h"#include "delay.h"void KEY_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE); //使能PORTA,PORTE时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4; //KEY0-KEY2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入 GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //初始化GPIOE2,3,4 //初始化 WK_UP--&gt;GPIOA.0 下拉输入 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化GPIOA.0&#125;//按键处理函数，用来返回按键值//mode:0,不支持连续按;1,支持连续按;//各种返回值代表的情况：//0，没有任何按键按下//1，KEY0按下//2，KEY1按下//3，KEY2按下 //4，KEY3按下 WK_UPu8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//按键按松开标志 if(mode)key_up=1; //支持连按 if(key_up&amp;&amp;(KEY0==0||KEY1==0||KEY2==0||WK_UP==1)) // if条件句判读是否有按键按下，有则执行判断语句 &#123; delay_ms(10); //去抖动 key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(KEY2==0)return KEY2_PRES; else if(WK_UP==1)return WKUP_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;KEY2==1&amp;&amp;WK_UP==0)key_up=1; return 0; // 无按键按下&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//main.c#include "stm32f10x.h"#include "led.h"#include "beep.h"#include "key.h"#include "sys.h"#include "delay.h"int main()&#123; u8 key=0; delay_init(); //延时函数初始化 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 beep_init(); //初始化蜂鸣器端口 LED0 = 0; //先点亮红灯 while(1) &#123; key = KEY_Scan(0); //得到键值 if(key) &#123; switch(key) &#123; case WKUP_PRES: //控制蜂鸣器 BEEP = !BEEP; //取反，则蜂鸣器不叫 break; case KEY2_PRES: //控制LED0翻转 LED0 = !LED0; break; case KEY1_PRES: //控制LED1翻转 LED1 = !LED1; break; case KEY0_PRES: //同时控制LED0,LED1翻转 LED0 = !LED0; LED1 = !LED1; break; &#125; &#125;else delay_ms(10); &#125; &#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VSCode写博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8VScode%E5%86%99%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[使用原因偶然之间看到一篇文章推荐使用VSCode，对于它我也是早有耳闻，一个开源的代码编辑器，但是之前觉得麻烦，觉得自己已经有了Visual Studio 2017就没必要再下一个代码编辑器了，当时以为VSCode不带有编译功能。 昨晚没事干，就下了个尝试一下啊，果然耳目一新，觉得从颜值也好，使用上也好都很舒服，但在配置的时候也遇到了问题，研究了好久才终于解决，特此记录！ 步骤 从官网安装VSCode 安装MinGW64,并将bin文件添加到Path路径中 安装插件 成功运行代码！ 具体过程从官网安装VSCode过程比较简单，从Google搜索VSCode进入官方网站，下载Windows的版本，运行即可。 安装MinGW64由于想在VSCode里跑C代码，最开始下了个C/C++的扩展程序，以为就可以用Fn+F5正常运行，实则不然，遇到报错！ 1提示这个内容：lauch:program does not exist 并要求我修改launch.json文件，可是我怎么修改也不管用…逐渐开始进入崩溃状态，想要直接写在这**的VSCode…可是作为一个颜控的我沉迷于VSCode的颜值无法自拔，决定再试试… 最终发现问题出现在没有安装MinGW64无法调试，于是搜索教程，前往官网下载，并将bin文件的目录添加到path路径中去。 并最终用gcc -v测试是否安装成功，要注意在cmd里测试，不要像我一样，在cmder里怎么测试都不成功… 安装具体教程点击这个链接 安装插件VSCode不安装插件是没有灵魂的… 我目前还不是很懂，也只是安装了一下几个插件 C/C++ C++ Intellisense Chinese Language Code Runner Seti-theme 运行代码最终用配置好的环境跑了一下hello，world成功编译！ 问题补充（修改于19.8.14）再次出现问题！之前成功编译只是通过了代码右上角的“播放”按键，也就是插件Code Runner，然而F5依然无法通过！ 继续查阅资料，查到一篇比较详细的教程，地址请点击 简单来讲就是还要修改.vscode文件夹里的launch.json和tasks.json文件。 而我是将launch.json修改为，其中gdb.exe的路径需要自己进行修改一下 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "program": "$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe",// 将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceFolder&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceFolder&#125;即代码所在目录 "environment": [], "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "MIMode": "gdb", "miDebuggerPath": "D:\\MinGW64\\mingw64\\bin\\gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应 "preLaunchTask": "g++", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ] &#125; 将tasks.json修改为 1234567891011121314151617&#123; "version": "2.0.0", "command": "g++", "args": ["-g","$&#123;file&#125;","-o","$&#123;fileBasenameNoExtension&#125;.exe"], // 编译命令参数 "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "$&#123;workspaceFolder&#125;"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;&#125; 最终实现F5调试并且可以实现断点debug等功能 使用VSCode编辑博客VSCode让我比较喜欢的一点是在于可以直接打开文件夹，并且继承了终端处理，git等，很多功能我还没有发掘出来，之后会深度体验一下VSCode！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】手把手写跑马灯实验]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E6%89%8B%E6%8A%8A%E6%89%8B%E5%86%99%E8%B7%91%E9%A9%AC%E7%81%AF%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[库函数版本回顾GPIO基础知识4种输入模式： 输入浮空 输入上拉 输入下拉 模拟输入 4种输出模式： 开漏输出 开漏复用功能 推挽式输出 推挽式复用功能 3种最大输出速度： 2MHZ 10MHz 50MHz 寄存器 GPIOx_CRL : 端口配置低寄存器（低8位） GPIOx_CRH: 端口配置高寄存器（高8位） GPIOx_IDR: 端口输入寄存器 GPIOx_ODR: 端口输出寄存器 GPIOx_BSRR: 端口位设置/清除寄存器 GPIOx_BRR : 端口位清除寄存器 GPIOx_LCKR: 端口配置锁存寄存器 跑马灯的硬件连接 LED0连接PB5 LED1连接PE5 库函数介绍 头文件：stm32f10x_gpio.h 源文件：stm32f10x_gpio.c 具体函数1个初始化函数：12345678910void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);//作用：初始化一个或者多个IO口（同一组）的工作方式和速度。该函数主要是操作GPIO_CRL(CRH)寄存器//样例 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //LED0--&gt;PB.5 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //根据设定参数初始化GPIOB.5 2个读取输入电平函数：123456789uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：读取某个GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。//举例：GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输入电平uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);//作用：读取某组GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。//举例：GPIO_ReadInputData(GPIOA);//读取GPIOA组中所有IO口输入电平 2个读取输出电平函数：123456789uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。//例如：GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输出电平uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);//作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。//例如：GPIO_ReadOutputData(GPIOA);//读取GPIOA组中所有io口输出电平 4个设置输出电平函数：123456789void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器//例如：GPIO_SetBits(GPIOB,GPIO_Pin_5); //GPIOB.5设置为高电平，LED高电平不亮void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。//例如： GPIO_ResetBits(GPIOB,GPIO_Pin_5);//GPIOB.5设置为低电平，LED高电平亮 代码思路 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd(); 初始化IO口模式。调用函数GPIO_Init(); 操作IO口，输出高低电平GPIO_SetBits(),GPIO_ResetBits(); 最终代码1234567//led.h 文件#ifndef __LED_H#define __LED_Hvoid LED_Init(void);#endif 1234567891011121314151617181920212223//led.c 文件#include "led.h"#include "stm32f10x.h"void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //GPIO初始化定义 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //GPIOB时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); //GPIOE时钟使能 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //端口配置 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOB,&amp;GPIO_InitStructure); //根据设定参数初始化GPIOB.5 GPIO_SetBits(GPIOB,GPIO_Pin_5); //GPIOB.5设置为高电平，LED高电平不亮 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE,&amp;GPIO_InitStructure); GPIO_SetBits(GPIOE,GPIO_Pin_5);&#125; 1234567891011121314151617181920// main.c#include "stm32f10x.h"#include "led.h"#include "delay.h"int main(void)&#123; LED_Init(); delay_init(); while(1)&#123; GPIO_SetBits(GPIOB,GPIO_Pin_5); GPIO_SetBits(GPIOE,GPIO_Pin_5); delay_ms(500); GPIO_ResetBits(GPIOB,GPIO_Pin_5); GPIO_ResetBits(GPIOE,GPIO_Pin_5); delay_ms(500); &#125;&#125; 寄存器版本代码思路 使能IO口时钟。配置寄存器RCC_APB2ENR 初始化IO口模式。配置寄存器GPIOx_CRH/CRL 操作IO口，输出高低电平。配置寄存器GPIOX_ODR或者BSRR/BRR 最终代码12345678//led.h 文件//与库函数版本相同#ifndef __LED_H#define __LED_Hvoid LED_Init(void);#endif 123456789101112131415161718192021//led.c 文件#include "led.h"#include "stm32f10x.h"void LED_Init(void)&#123; RCC-&gt;APB2ENR |= 1&lt;&lt;3; //使能IO口时钟，GPIOB RCC-&gt;APB2ENR |= 1&lt;&lt;6; //使能IO口时钟, GPIOE //GPIOB.5 GPIOB-&gt;CRL &amp;= 0xFF0FFFFF; //先用与运算将欲修改的位修改为0（修改第六位） GPIOB-&gt;CRL |= 0x00300000; //再用或运算将PB5修改为通用推挽输出，即0011，也就是3 GPIOB-&gt;ODR |= 1&lt;&lt;5; //将PB5的ODR寄存器设置为高电平，即最开始不亮 //GPIOE.5 GPIOE-&gt;CRL &amp;= 0xFF0FFFFF; //同理 GPIOE-&gt;CRL |= 0x00300000; GPIOE-&gt;ODR |= 1&lt;&lt;5; &#125; 12345678910111213141516171819//main 文件#include "stm32f10x.h"#include "led.h"#include "delay.h"int main()&#123; LED_Init(); delay_init(); GPIOB-&gt;ODR |= 1&lt;&lt;5; GPIOE-&gt;ODR |= 1&lt;&lt;5; delay_ms(500); GPIOB-&gt;ODR = ~(1&lt;&lt;5); GPIOE-&gt;ODR = ~(1&lt;&lt;5); delay_ms(500);&#125; 位带操作版本位操作原理把每个比特膨胀为一个32位的字，当访问这些字的时候就达到了访问比特的目的，比如说BSRR寄存器有32个位，那么可以映射到32个地址上，我们去访问（读-改-写）这32个地址就达到访问32个比特的目的。 代码思路 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd() 初始化IO口模式。调用函数GPIO_Init() 操作IO口，输出高低电平。使用位带操作。 最终代码123456789//led.h 文件#ifndef __LED_H#define __LED_H#define LED0 PBout(5)// PB5 添加宏定义#define LED1 PEout(5)// PE5 void LED_Init(void);#endif 123456789101112131415161718192021//main 文件#include "stm32f10x.h"#include "led.h"#include "delay.h"int main()&#123; LED_Init(); delay_init(); while(1)&#123; LED0 = 1; LED1 = 1; delay_ms(500); LED0 = 0; LED1 = 0; delay_ms(500); &#125;&#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用GCC编译Keil5的代码，了解GCC工具链]]></title>
    <url>%2F%E3%80%90STM32%E3%80%91%E7%94%A8GCC%E7%BC%96%E8%AF%91Keil5%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BA%86%E8%A7%A3GCC%E5%B7%A5%E5%85%B7%E9%93%BE.html</url>
    <content type="text"><![CDATA[用GCC编译Keil5的代码，了解GCC工具链引言本周接到任务，首先是熟悉STM32cubemx，既然是熟悉框也就不做太高的要求，毕竟也只是一个提升效率的工具，我就按照教程新建了一个简单地模板，算是知道怎么用cubemx从头开始建一个工程了。 而本周的第二个任务就是研究用GCC工具链编译Keil5的代码，这个的确对我来说难度不小，算是卡了我将近三天的时间，而出现这个问题的原因就是我基础不够牢靠，Keil5软件最基本的知识没有掌握，导致找不到问题的原因所在。还好我中途没有放弃，一直在尝试，也一直在找可能的原因，最终找到了，也算功夫不负有心人吧。 特此记录一下，因为我在出现这些问题之后并不能在网上找到答案，借此机会来帮助之后和我一样基础不好的小白吧。 问题产生在研究用GCC编译Keil5的代码的时候，我在网上找到了CSDN上的一个教程，讲解的还是十分详细的。 但我按照教程，把我用cubemx建的工程搞了一遍却出现了很多很多的bug，具体如下： 遇到这个问题之后我也查了一下，并没有找到原因，多数是说我没有定义，但我也不知道应该怎么定义呀！ 寻找问题我的直觉觉得问题可能出在教程中配置的部分，但同样的配置为什么会出现不同的结果呢？ 我于是按照正点原子的教程从头开始看了一下怎么配置一个用armcc编译的流水灯模板，因为之前我没自己搞过模板，于是发现了很多我之前不知道的细节，比如添加添加定义，头文件，修改output输出文件夹，而我出现的问题就是define没有添加，导致未定义。 12//在图中define一定要添加Define: USE_HAL_DRIVER,STM32F103xE,USE_HAL_DRIVER,STM32F103xE 解决之后成功编译！ 附上可编译模板的链接]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【从零入门Qt】开发一款属于自己的串口调试助手]]></title>
    <url>%2F%E3%80%90%E4%BB%8E%E9%9B%B6%E5%85%A5%E9%97%A8Qt%E3%80%91%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B.html</url>
    <content type="text"><![CDATA[暑假来深圳这边实习，做的是嵌入式方向，负责人分配给我的第一个任务是用Qt写一个串口调试助手。这个任务总体来讲难度适中，尽管我没接触过Qt，但能查到很多很多的资料，甚至包括别人写好的源代码，所以有很多的学习资源。 我第一天在同学的推荐下，看了一个入门的文档，《Qt 学习之路 2》，其中内容讲的比较基础，基本可以理解，算是能对Qt的语法了解个大概。而且如果实在不懂，也可以参看b站上的视频教程，是黑马程序员的教程，视频内容比较冗长，但对于初学者来说可能更好理解，各取所需，看个人选择。 因为负责人只给了我三天的时间，所以我也就花了一天左右的时间看教程，就开始看我在网上看的一份源码了。当时我的进度是黑马程序员看了不到10个视频，《Qt 学习之路 2》看了不到20节教程，虽然说看了不少，但我当时还是很慌的，对于我这种小白来说，还是不知道源代码是什么意思，但这个时候我能大概明白每个函数要做什么功能了，也就是我看懂了函数名，但函数里的句子我看不懂。 然后我就选择了按照这份代码自己复刻一份，算是尝试着自己写一下。 于是我新建了一个project，名字是Myserialport，发现源代码中main.cpp完全一样，也就是一个窗体的显示功能，很好理解，直接略去~ 上面的mainwindow.h文件里面有很多库函数的引用，函数的声明，我姑且认为不重要，暂时略去 而代码最多的就集中在mainwindow.cpp文件里了，也是我最需要解决的部分！ 这是我新建工程后的代码： 1234567891011121314#include "mainwindow.h"#include "ui_mainwindow.h"MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 而源代码在MainWindow::MainWindow(QWidget *parent)中添加了很多窗体生成的初始化语句 123456789101112131415MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); textstate_receive = false; //初始化发送窗口状态为文本模式 textstate_send = false; //初始化接收窗口状态为文本模式 serialport = new QSerialPort; //创建QSerialPort类，需要在头文件中添加#include &lt;QSerialPort&gt; ui-&gt;send_button-&gt;setEnabled(false); //初始化接收按钮不可用 ui-&gt;close_port-&gt;setEnabled(false); //初始化接收按钮不可用 ui-&gt;Receive_text_window-&gt;setReadOnly(true);//讲接收窗口设置为只读窗口 setWindowTitle("串口调试助手"); //设置程序的标题 setWindowIcon(QIcon(":/images/exe.jpg")); //设置程序左上角图标 find_port(); //查找可用串口函数&#125; 以上语句还是比较好理解的，每句话我都进行了注释。 下面的代码就是定义各个函数，而.h文件里的很多函数声明也就很好理解了，也就是在.h文件里定义一下各个函数 比如以下很重要的两个函数，用于实现数据的发送和接收 123456789101112131415161718//发送数据void MainWindow::on_send_button_clicked()&#123; if(textstate_send == false) //文本模式 &#123; serialport-&gt;write(ui-&gt;Send_text_window-&gt;toPlainText().toUtf8()); &#125; if(textstate_send == true) //hex模式 &#123; QString str = ui-&gt;Send_text_window-&gt;toPlainText(); int num = str.toInt(); str = str.setNum(num,16); ui-&gt;Send_text_window-&gt;clear(); ui-&gt;Send_text_window-&gt;append(str); serialport-&gt;write(ui-&gt;Send_text_window-&gt;toPlainText().toLatin1()); &#125;&#125; 123456789101112131415161718192021222324252627//窗口显示串口传来的数据void MainWindow::Read_Data()&#123; QByteArray buf; buf = serialport-&gt;readAll(); if(!buf.isEmpty()) //将数据显示到文本串口 &#123; if(textstate_receive == false) //文本模式 &#123; QString str = ui-&gt;Receive_text_window-&gt;toPlainText(); str += tr(buf); ui-&gt;Receive_text_window-&gt;clear(); ui-&gt;Receive_text_window-&gt;append(str); &#125; if(textstate_receive == true) //hex模式 &#123; QString str = ui-&gt;Receive_text_window-&gt;toPlainText(); // byteArray 转 16进制 QByteArray temp = buf.toHex().toUpper(); str += tr(temp); ui-&gt;Receive_text_window-&gt;clear(); ui-&gt;Receive_text_window-&gt;append(str); &#125; &#125; buf.clear(); //清空缓存区&#125; 最后实现了以下的界面，以及文本模式和16进制（hex模式）两种模式转换的数据收发 p.s.：尝试了很久想要解决中文无法显示的问题，最终无果… 有需要的话可以在这个链接下载嗷~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式开发学习笔记]]></title>
    <url>%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Linux distribution (linux的发行版本)软件，shell 保护层，kernel内核，硬件 linux系统，完整的分层模型 RedHat：server 服务器 面向企业用户 具有license CentOS：已经被红帽子收购，开源免费版本，区别于企业版，比较稳定 以上两款界面不好看，不追求绚丽的东西 Ubuntu：稳定性不如上面两个，但适用于普通用户，中文支持，软件支持做的都比较好 ubuntu操作 sudo 为普通命令提升权限 sudo passwd root su - 切换到系统的身份 apt-get update更新源，用于下载新的安装包（如果是普通用于，记得在前面加sudo 尽量用命令行的方式来学习linux vim安装 apt-get install vim-nox vi已经安装，是一个编辑软件的记事本 vim回车，进入 退出，敲：q（不知道要不要加！） vim全键盘操作，效率很高 cd / 根目录 c—change d—directory 目录 ls 不要在根目录里面操作 回去 cd vi /etc/ vi 命令模式，编辑模式，用 i 切换模式，esc键退出 ssh-secure shell SecureCRT安装 sshd回车 apt-get install openssh-server ifconfig net add: rz zmodem r:receive sz zmodem s:send samba apt-get install samba]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言学习笔记]]></title>
    <url>%2F%E3%80%90C%E3%80%91C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[我为什么要学习C语言说来惭愧，作为一个工科学生，我竟然没有学过C语言，只在大一的时候学过一学期的VB，虽然语言这种东西说起来都差不多，但毕竟也是将近三年前的事了，早就忘光了。 可是不掌握C语言真的很麻烦，这尤其体现在做单片机上，单片机要求我们使用C语言，我当时连那些代码都看不懂，更别谈让我自己去写了。 正好，最近时间比较充沛。拿出时间来把C语言好好学学 p.s. 突然想起来我初中好像就学过C++了，但只是皮毛 我用什么工具学习C语言书籍：C程序设计语言（第二版 新版）→ 纸质 软件：VS2017, Xcode 其它：Google，CSDN，Baidu 我的第一段代码1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello, world.\n"); system("pause"); //return 0;&#125; main函数：main是一个特殊的函数名——每个程序都从main函数的起点开始执行。main函数通常会调用其它函数来帮助完成某些工作 本例中main函数不需要任何参数 用双引号括起来的字符序列称为字符串或字符串常量 \n 表示换行符 第二段代码1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* 当fatr = 0,20,...,300时，分别打印华氏温度与摄氏温度对照表 */main()&#123; int fahr, celsius; int lower, upper, step; lower = 0; /* 温度表的上限 */ upper = 300; /* 温度表的下限 */ step = 20; /* 步长 */ fahr = lower; while (fahr &lt;= upper) &#123; celsius = 5 * (fahr - 32) / 9; printf("%d\t%d\n", fahr, celsius); fahr = fahr + step; &#125; system("pause");&#125; 其中，int表示其后所列的变量为整数，与之对应的float表示浮点数（即可以带有小数部分） 为什么不用5/9？因为C语言存在舍位，小数部分都会被舍弃 Bit &amp; Byte 字节(Byte): 通常将可表示常用英文字符8位二进制称为一字节 比特(Bit)，亦称二进制位 ，1比特就是1位 1字节(Byte） = 8位(bit) 在ASCII码中，一个英文字母(不分大小写)占一个字节的空间，一个中文汉字占两个字节的空间 符号：英文标点占一个字节，中文标点占两个字节 1千吉字节（TB,Terabyte）=1024吉字节（2的40次方字节）（1TB=1024GB） 1吉字节（GB,Gigabyte）=1024兆字节（2的30次方字节）（1GB=1024MB） 1兆字节（MB,Megabyte）=1024千字节（2的20次方字节）（1MB=1024KB） 1千字节（KB,Kilobyte）=1024字节（2的10次方字节）（1KB=1024B） 1字节（Byte）= 8位（bit） 计算机中的位 二进制数系统中，每个0或1就是一个位(bit)，位是数据存储的最小单位。其中8bit就称为一个字节（Byte）。计算机中的CPU位数指的是CPU一次能处理的最大位数。例如32位计算机的CPU一次最多能处理32位数据。 所以char类型的存储大小为1个字节，也就是8位，这8位代表8位二进制， 浮点类型 类型 存储大小 精度 float 4 字节 6 位小数 double 8 字节 15 位小数 long double 16 字节 19 位小数 void类型 序号 类型与描述 1 函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 printf 输出```%a 浮点数、十六进制数字和p-记数法（c99%A 浮点数、十六进制数字和p-记法（c99）%c 一个字符(char)%C 一个ISO宽字符%d 有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。） %e 浮点数、e-记数法%E 浮点数、E-记数法%f 单精度浮点数(默认float)、十进制记数法（%.nf 这里n表示精确到小数位后n位.十进制计数）%g 根据数值不同自动选择%f或%e．%G 根据数值不同自动选择%f或%e.%i 有符号十进制数（与%d相同）%o 无符号八进制整数%p 指针%s 对应字符串char（%s = %hs = %hS 输出 窄字符）%S 对应宽字符串WCAHR（%ws = %S 输出宽字符串）%u 无符号十进制整数(unsigned int)%x 使用十六进制数字0xf的无符号十六进制整数 %X 使用十六进制数字0xf的无符号十六进制整数%% 打印一个百分号 %I64d 用于INT64 或者 long long%I64u 用于UINT64 或者 unsigned long long%I64x 用于64位16进制数据 ​]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脸上各部位长痘痘的原因及调理方法汇总]]></title>
    <url>%2F%E8%84%B8%E4%B8%8A%E5%90%84%E9%83%A8%E4%BD%8D%E9%95%BF%E7%97%98%E7%97%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%B0%83%E7%90%86%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[额头痘状况：有可能是压力太大，容易脾气不好，造成心火和血液循环有问题。 改善：应养成早睡早起的习惯，让睡眠充足，并多喝水。 印堂痘状况：出现在两眉正中间的痘痘，通常有胸闷、心律不整、心悸等毛病。 改善：不要尝试太过激烈的运动，要避免烟、酒等刺激性的食品。 发髻痘状况：因为卸妆没有卸干净，造成毛孔堵塞河污染，容易在较闷的发髻或眉间形成细小痘痘。 改善：加强卸妆和清洁的工作，一定要彻底搓揉干净，每星期做一次去角质工作，报纸皮脂腺顺畅。 鼻翼痘状况：突然冒出的肿大痘痘，可能是卵巢机能或者生殖系统有关。 改善：不要过度纵欲或禁欲，尽量走出户外，享受降的自然环境。 鼻头痘状况：可能是胃火过大，消化系统异常。 改善：少吃冰冷食物，寒性食品容易引起胃酸分泌，造成胃火过大。 眼头痘状况：K近鼻子和眼头区域的痘痘，通常是肝机能不好所引起。 改善：生活作息要正常，避免熬夜，尽量在11点前上床睡觉。 唇周痘状况：便秘导致体内毒素累计，或者是使用含氟过量的牙膏，都是造成唇周痘痘的主因。 改善：多吃高纤维的蔬菜水果，调整饮食习惯，刷牙漱口要彻底。 下巴痘状况：通常是月经要来的前几天，造成内分泌失调所引起的。 改善：少吃冰冷的东西，月经期间可用消炎镇定的保养品。 右边脸颊痘状况：可能是肺部功能失常，手脚冰冷，或是容易敏感的体质，也有可能是感冒前兆。 改善：平时注意呼吸道的保养，尽量避免芒果、芋头、海鲜甲壳类易过敏的食物。 左边脸颊痘状况：可能是肝功能不顺畅，如肝脏的分泌、解毒或造血等功能出了状况。 改善：作息正常，保持心情愉快，该吹冷气就吹冷气，不要让身体处在过度闷热。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我在大学各学期大致课外学习规划]]></title>
    <url>%2F%E6%88%91%E5%9C%A8%E5%A4%A7%E5%AD%A6%E5%90%84%E5%AD%A6%E6%9C%9F%E5%A4%A7%E8%87%B4%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.html</url>
    <content type="text"><![CDATA[大二下学期：学控制，以Arduino为主，可能学不完，学不透，暑假继续 大三上学期：转去学机器人学（Matlab），也算是为之后去参加数模美赛做基础 大三下学期：如果有精力可以去学Linux，ROS 大四：Linux，ROS，Python，Tensorflow…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专业导论课最后一节个人认为比较有价值内容整理]]></title>
    <url>%2F%E4%B8%93%E4%B8%9A%E5%AF%BC%E8%AE%BA%E8%AF%BE%E6%9C%80%E5%90%8E%E4%B8%80%E8%8A%82%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E6%AF%94%E8%BE%83%E6%9C%89%E4%BB%B7%E5%80%BC%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[机械工程伦理问问自己：内心世界? 存在的意义? 为何要多一点形而上? 你的价值感? 你的技术创造的欲求? 技术工作者/工程师的责任? 你对未来技术的感觉? 知识、能力与素质的区别和联系 核心 t特点 知识 人类认识的成果 形成能力，素质的基础 能力 完成一定活动的本领 对知识的运用，是知识发挥作用的实践条件，具“外显性” 素养 基本品质或基础条件 人在活动过程中所塑造成的内在升华，具“内凝性” 专业教育组成数学类和自然科学类总计最少为450学时 工程科学类、工程设计与实践类两者总计最少1000学时 人文和社会科学不少于400学时 机械专业教育知识体系包含如下5个知识领域 机械设计的原理与方法 机械制造工程原理与技术 机械系统中的传动和控制 计算机应用技术 热流体 中国加入《华盛顿协议》国内本科生获得的文凭，在国际上都会被认可 企业对毕业生能力的评价 独立性强、思路开阔、时尚; 知识面广; 不够踏实、团队协作意识弱; 不能承受较大压力,工作责任心、事业心弱,急功近利; 熟悉、胜任本职工作需要的时间较长,须在企业工作3-4年左右才能完全胜任工作。 企业对毕业生能力的期待 除专业能力外,最基本的要求是踏实、勤奋、敬业、忠诚、合作; 感兴趣的主要不是学习成绩,更注重处理问题的能力、解决问题的能力以及工作中的综合性能 很看重学生的整体素质和品德.]]></content>
      <categories>
        <category>华科机械学习资料分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于项目的几个想法]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95.html</url>
    <content type="text"><![CDATA[关于项目的几个想法手机app：百词斩手部控制器 备忘录锁屏提醒 实物：AGV跟随小车：用来背书包，也可背在身上 可折叠快递柜 自动洗头机器人]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS入门]]></title>
    <url>%2FROS%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[鸟哥私房菜1 2 3章作为了解，第4 5 6章随书操作一遍，这样大家对Linux系统的基本操作会有一个大致的认识。注意，鸟哥书中系统与我们不同，因此不要太纠结于必须每一步结果都与书中一样。另外，遇到问题的话，把问题复制下来直接百度，绝大多数问题是有解决方法的。 ROS_Robot_Programming_CN电子书1、2章粗略浏览，3~7章重点学习，后续章节以后再说。]]></content>
      <categories>
        <category>华科机械学习资料分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laplace拉氏变换公式表]]></title>
    <url>%2FLaplace%E6%8B%89%E6%B0%8F%E5%8F%98%E6%8D%A2%E5%85%AC%E5%BC%8F%E8%A1%A8.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Laplace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦里花落知多少]]></title>
    <url>%2F%E6%A2%A6%E9%87%8C%E8%8A%B1%E8%90%BD%E7%9F%A5%E5%A4%9A%E5%B0%91.html</url>
    <content type="text"><![CDATA[很喜欢何炅说的一段话：要得到你必须要付出，要付出你还要学会坚持，如果你真的觉得很难，那你就放弃，但你放弃了就不要抱怨，我觉的人生就这样的，世界真的是公平的，每个人都是通过自己的努力，去决定自己生活的样子！ 我的2020年FLAG： 建一个自己的博客 GRE330+ TOEFL110+ UCLA]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华科机械学院大二下学习资料分享]]></title>
    <url>%2F%E5%8D%8E%E7%A7%91%E6%9C%BA%E6%A2%B0%E5%A4%A7%E4%BA%8C%E4%B8%8B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html</url>
    <content type="text"><![CDATA[各科目课件百度网盘链接 提取码：y8iy]]></content>
      <categories>
        <category>华科机械学习资料分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[朝花夕拾]]></title>
    <url>%2F%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE.html</url>
    <content type="text"><![CDATA[20190609该结束的课程终于都结束了，剩下的就是两个期末考试了。最近也是十分的空虚和无聊，呜呜。 昨天和黄智威出去吃饭，也是觉得自己突然刷新了自己对生活的认识，或许想在这个社会上生存，不能只想着简简单单的一个人打拼，在几个人的小团体里活着。想要在这个社会上获得你的地位，需要建立自己的人脉网，才能在走入社会后吃得开，显然，我目前并不是这样的人，我喜欢呆在自己极小的圈子，甚至在这个小圈子里我也很少和周围的人沟通交流，我也明白这样是不对的，慢慢去改变吧。 20190610今天早上起来之后就觉得不对头，脖子不是很舒服，像是落枕了。 这几天也没有好好休息，听了别人说每晚要早点睡觉，自己也在暗下决心，可是每晚躺倒床上就打起了精神，想要看会儿手机再睡，这一看就不是一会儿两会儿能解决的事情了，往往会熬夜到后半夜才会睡觉，周末利用空闲时间还想玩玩游戏，我应该知道自己颈椎不好不要总是低头玩手机用笔记本，但内心的躁动总是难以压抑，每次之后内心又充满了后悔。这就是太过放纵自己的结果。 身体最重要！永远不要和自己的身体开玩笑，永远不要做有害自己身体的事情，不然后悔都来不及 20190614感觉自己距离实习、工作还有好大的一段距离啊，真的要抓紧要努力了 自己没事做做眼保健操，保护眼睛 20190626今天没事闲的，在百度上搜索了一下自己，发现一个文档，是16年吉林一中所有毕业生的去向。说实话，这个表格我从没打开过，也没看过，所以我也不知道自己在这么一批人中到底处于一个什么层次什么位置。无奈，手贱点开了，内心难免升起波澜。我想如果我当年看了这个表格的话，我应该会选择复读吧。不是很好的学校的最差专业，这个报考也是很不明智。难怪我觉得来到这个学校和我期待的大学不一样，因为我的确没有去上我所期待的大学啊。 最开始来到这里之后先是觉得不适应，觉得自己不属于这里，后来慢慢适应了，也习惯这里的一切，后来自己又变成了这一批人里的中游，想想还是蛮扎心的。 今天看到这个也算给自己一个警示，我不该这么消沉，我应该去追求属于我自己的未来。包括来到大学，我也不是很努力，我一直都不是一个努力型人格，喜欢放纵自己，跟着自己的性子来，这样的话，等到大学毕业，我可能还是同样的结局，真是活该啊！ 人应该今早认识到一点：人这一生，靠的不光是实力，也看运气，运气也是实力的一种 20190702考完试啦，也把博客搬迁到我的mac上了，还是蛮简单的 遇到了点小问题但是都解决了，蛮好 Everything we can just google it! 20190703整理一下思路 为实习做准备需要学习：c, linux, arm 为下学期机器人学做准备需要学习：机器人学, Matlab 为出国做准备需要学习：toefl 为下学期课程做准备应该学习：机械原理等课程 为未来接触更新的知识做准备应该学习：python, tensorflow 为了更好的身体我应该：每天坚持健身 那么，到底是应该每天一个部分学一点还是应该阶段性的学习一个内容呢？ 20190706凡事应该谨言慎行，不可草率啊。事不过三，事不过三 我觉得我就是一个宅男，屌丝。。至少目前阶段是的，我承认。。要改吗？能改吗？，，我倒是很希望自己能成为一个技术控，人总是要有自己的一点特长的啊 昨晚看了个电影，蜘蛛侠英雄远征，个人觉得比较一般，以后最好不要看这种电影了 今天是最后一天休息了，明天开始生活就要走上正轨了，准确的说今天也不应该休息的。作为学生，每天必须要有八个小时的学习时间。这几天都没达到吧。。 20190707哥伦比亚大学门口的雕塑是女神雅典娜，还藏了一只猫头鹰，象征着智慧。 大学要培养的是可迁移的能力 没事多听听ted什么的别看直播了！ 科研项目并不是学校的那种科研，而是国外背景的科研 我第一喜欢的lpl输了，呜呜呜，以后不看比赛了，扎心呀 好好学习，报效祖国～～ 20190712原来变强是一定要付出代价的，健身也好，学英语也好，都是一个循序渐进的过程，不会有立竿见影的效果，但每天的练习一定会内化到身体里成为你的一种力量！无论什么时候都要顶住，顶住压力，坚持下去✊]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在2019年高考前]]></title>
    <url>%2F%E5%86%99%E5%9C%A82019%E5%B9%B4%E9%AB%98%E8%80%83%E5%89%8D.html</url>
    <content type="text"><![CDATA[我对高考的记忆真的剩下的很少了 我记不起来那天发生了什么，也记不起来我的任何分数，更记不起来考了什么题目 我能记起来的，只有发成绩那天我妈的泪水。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机惊云（二）]]></title>
    <url>%2F%E6%89%8B%E6%9C%BA%E6%83%8A%E4%BA%91%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[电梯很长，人也不少，除了地铁口我就看到了一个穿着粉色t恤，年级估摸着有将近五十岁，个子不是很高的中年人，有一点油腻，猥琐的气质，但看起来不像是坏人 我故作镇定的走过去，和他说：”你为什么上来了？“ 他说：”我没做地铁来，我那里没有地铁，我骑车过来的。“ wdnmd…武汉哪里没地铁我是不信的 算了算了，你骑车就骑车吧，直接验货（滑稽） 我就找了个地方，从书包里掏出了我的手机 他说：”我没用过苹果手机，你这个手机咋用啊？” 我心想：哎呦，遇到外行了 他随便操作了几下，鬼知道他怎么操作的，竟然操作到了多任务栏，他尝试上滑关掉应用，竟然没关掉？？？ 我当时也懵了，这个情况我也没遇见过啊，我好几周都没用过这个手机了，我心里也不是很确定，不会是坏了吧？ 我就自己拿过来操作了几下，发现的确不行，我心里开始发慌，还好他也没有说什么 于是我就开始解释，手上还是在操作，想着是不是什么设置没打开？ 就在我调的时候他手机响了，我瞄了一眼，这TM不就是苹果手机吗？？？你跟我说你没用过苹果手机不会用？ wdnmd，你这有什么骗我的 内心暗自怀疑 我继续在那里试怎么关不掉多任务 也不知道我怎么按的，就长按了屏幕，左上角出现了一个红色的关闭按钮，我点了一下应用就关掉了 wdnmd！这什么智障设计，苹果真的不如我手里的安卓好用啊，这个设计也太脑残了吧。。。 暗自感叹了一下之后，心想：还好度过了难关，手机肯定没问题，你随便验 他又调了几下铃声什么的，发现都没问题 他又问我：“你带针没？我把卡插进去试一下。” 。。。 我带这玩意儿干啥，我哪知道您这么急啊 我说：“我没有，但肯定没问题，我用的好好的，你就放心吧。” 他的表情明显告诉我他不相信，他说他想试试话筒，他说他的手机话筒坏了 但他看是在是没法子，就说：“那就这样吧，有问题我给你打电话联系你。” 我说好 之后就开始转账了，我打开了我的支付宝收钱， 他很快扫了我的码，很果断的付了钱，谁知道我没收到提示 我心想原来你是用这种不付钱的骗术来骗我 哼，也太低级了吧，我早就听说过这种骗术了 别想用这种方法骗到我！ 我手里死死的握着我的手机不放，谁知道他开始急了 他说：“你咋没收到呢？我都付过去了啊？“ 我看着他手机上的账单，的确是这样，显示的已付款 难道这又是什么新型骗术吗？ 我手机疯狂刷新，还是没有，唉？咋回事 我看到我手机上的信号突然没了，半天之后才有，也就听到了那熟悉的：”支付宝到账…“ 突然心里一阵舒爽，这下落袋为安了哈哈 我就开学的走了，走之前回头看了他一眼，我看他急匆匆的往地铁站走，像是要去坐地铁 我心想，你TM不是做不了地铁吗？ 算了，管他呢，反正也结束了 看着他那粉色t恤的背影，我也回头往学校走，脑子里还在想着晚上吃点什么的问题 可谁又知道，事情才刚刚开始……]]></content>
      <categories>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手机惊云（一）]]></title>
    <url>%2F%E6%89%8B%E6%9C%BA%E6%83%8A%E4%BA%91%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[爸妈给换了个新手机，Huawei的，用着还挺顺手，用了好几年的iphone6sp就扔在寝室不用了。 旧手机在寝室放着一直看的挺烦的，也不是烦，就是想让每个东西都能有它们自己的归宿吧，不想让它们闲着。于是我就挂到了咸鱼上去，定了一个蛮高的价格，想着这么心爱的手机不想它这么就卖出去了… 果不其然，两天了没人来找我问，我心想，看来价格合适，不是那种贱卖的价格。我也没继续理它，反正我也不急着用这笔钱。 没想到今天下午我收到一个人的消息，他说他想买手机，还说他就在武汉，离我学校还挺近，说一会儿能不能当面交易，让我定一个地方。剧情发展的太快我根本没反应过来，而且他的果断和紧急让我更加的警觉，我在怀疑是不是什么骗局，毕竟闲鱼上的骗局还是很多的。 于是我马上追问：“在哪里交易？”（交易这个词怎么觉得怪怪的） 他说：“你定一个地方吧，我到时候直接给你现金。” 现金？？？ 我看到了一个关键词，立马勾起了我的警觉心。我马上在脑海里构想了各种可能的诈骗方式，比如什么钱是假钱，或者是他会以验机为名直接拿着我的手机跑路？…… 越想越后怕，我马上回：我不收现金，只接受转账。 我本以为他会因为我这么一说直接放弃这笔交易 没想到他直接回：没事，我们去银行门口见面，没问题的话我直接去ATM存钱，我手机里没钱！ 事情发展的更加扑朔迷离 奈何我一天下来也蛮累的，不如就用这个晚饭是时间休息下，把这个事情搞个明白，我倒是要看看这个人到底是个什么底细！ 紧接着我就挑了一个离学校在最近的地铁站，给他发了过去 我心想：地铁站人多而且有监控，就算你有问题，我也可以找别人来帮忙啊 我想着他会不会因为地点问题再次放弃交易 没想到，他又回了一句：我查查 真是出乎我的意料，难道他真的是要买手机？那为什么偏偏选择了我这个嘞？ 还没等我多考虑，他就回复我：”好的，我这就出门。“ 。。。 我当时人还在教室里呢，手机还在寝室躺着呢！ 心想：你是真急啊，你急的我害怕！… 我也来不及多想，收拾东西就往寝室走，因为我手机还没清理，里面还有好几10G的照片没删呢，还好我前几天把它们全上传到我的百度云里了。 回到寝室后，把手机刷掉，完全格式化，不想留下任何和我有关的信息 我在路上又想了一下，想到了更可怕的事情…他会不会用武力解决我并拿走我的手机… 虽然很离谱，但这种想法的确在我的脑子里的浮现过，而且当时脑子里的画面不是他一个人，是他带着他的一帮弟兄一起过来的，就像是那种黑帮电影里的感觉，一群光着膀子的大汉一排走过来…我是不是想象力太丰富了… 收拾的差不多，拿上了充电线就出门了，想着我耽误了这么久，他也该到了吧，临走前我还拿上了周二工程实训刚做好的喵喵锤。想着防身用hhh 然后我就往地铁站走了 到了地铁站，特意选了个出战的检票口，想着这旁边保安多得很，这下我的人身安全肯定没问题了吧 突然觉得自己真的机智，于是就找了个地方休息，也没再想什么有的没的。 过了十分钟他还是没消息，我心想，这该不会是不想买，但是要骗我时间的吧 话说我自己觉得我的时间宝贵，应该他不觉得吧 于是我就闲鱼给他发了个消息，说：你到了没？ 他过了半天才说：在路上，一刻钟到 一刻钟？？？我这么多年都没用过这个词，这个此时啥意思？是十五分钟的意思吗？ 我脑子里觉得是十五分钟，但还是不确定，我还特意去查了一下确认 哎，么得办法，买点东西是不容易啊，又冒着生命危险，又要浪费时间 可是我的书包也重的很啊，我还背着一个电脑，我总不能在这里傻站着等吧 关键是他说是十五分钟，到底是不是，谁知道啊？ 于是我就找了一个地方做了下去，刷起了手机。 刷手机时间还是过得快啊，大概不到二十分钟，他给我来了个电话 说他到了，没看到我。 我说：”我在地上坐着呢，你看到我没？“ 他说：”没有啊，你人呢？“ 我说：”我就在这个检票口出口啊。“ 他说：”我在上面，没在下面。“ 。。。 完了，之前的计划全部泡汤 但听他的声音，好像也不是很凶的样子，我就想着行吧，我上去会会你，反正我有小锤锤护身 然后我就上了电梯，往地铁口走]]></content>
      <categories>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那些你可能不知道的知识]]></title>
    <url>%2F%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[游戏里的SSR, SR, R, UR，N都是什么意思？ SSR：全称为superior super rare，表示特级超稀有; UR: 全称是Ultra Rare，表示极度稀有; SR: 全称是Super Rare，表示超稀有； R: 即Rare，表示稀有; N: 是Normal的缩写，表示普通; 64位是什么意思？一个 64 位的 CPU，内部可能有外部数据总线或不同大小的地址总线，可能比较大或比较小；术语“64位”也常用于描述这些总线的大小 在计算机架构中，64位整数、内存地址或其他数据单元，是指它们最高达到64位（8字节）宽。 API是什么？API（Application Programming Interface，应用程序编程接口） 对于浏览器来说（这也是所谓的客户端），Facebook的服务器就是一个应用程序编程接口。这意味着每当你在互联网上访问一个页面的时候，你都在与某个远程服务器的API发生交互。 API并不完全等同于远程服务器——它其实是服务器的一部分，负责接收请求并发送响应。 IDE是什么integreted development environment 即集成开发环境]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Hexo博客搭建经历]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[为什么要做自己的博客？说到为什么要这么做，这个想法也是已经有很久了。当时的起因是我想通过互联网上的某个平台来记录自己的学习笔记或者自己的一些思考。在知乎等搜索了很多，都没有找到太合适的，其中包括公众号，简书，csdn等等。我觉得不合适的原因有的是因为网站太过烟火气，对我来说我觉得不够“干净”。有的是因为我觉得和我的圈子不符合，有的是因为我个人的喜好，最终都没有选择。有一天就突然萌生了做一个自己的博客的想法！ 但问题来了，怎么做呢？我完全摸不到头脑。我就去知乎查了一下看到了蛮多科普的帖子，但一翻，好长好长，其中也包括很多很多的代码。对于一个机械专业的学生来说，看到这些内心是恐惧的。于是…我就把那篇帖子收藏了，打算等我有时间再做…当时可能觉得的时间是大四…可是这个想法实际上一直深深的埋在我的心里。 上周，这学期该忙的事情几乎结束，剩下的就是为了期末考试做准备了，我向来是一个喜欢拖延的人，不到考试前一周应该是打不起学习的兴趣的。我就在教室看着电脑，可能又萌生了写点东西的想法，奈何没有平台给我发挥。于是突然决定，就现在！把博客给我搞出来 我花了多少时间？总共时长大概是3天白天的时间，对于我这个毫无基础的IT小白来说还是可以接受的（毕竟如果我不是搞这个的话估计也不会学习吧） 我是怎么做出来的？遇到了很多问题，也查了很多资料，通过别人的教程一步一步完善自己的博客 推荐链接：知乎上的一篇文章，我的启蒙 看了这个博客之后大部分操作就都可以完成了，当然你可能会像我一样，遇到很多的问题，那么怎么办呢？当然是自己查！而且很容易查到你想要的解决方法 这篇博客是我的努力目标，当时就是朝着这个方向努力完善 这篇博客讲了很多博客美化的内容，我都是自己一步一步搞的 另一个美化博客的教程，也很不错哦 以上部分完成了，你的博客基本就完成啦！如果你遇到了什么问题，都可以去google，相信你能得到你想要的答案~ 会不会出教程？应该不会，教程太多了，我还没那么牛，等我再学习学习吧… 如果换电脑了，想在新电脑上写博客，怎么迁移一个比较好的教程 想在两台电脑上同时写博客的方法利用git的分支功能！ 把生成的静态网页上传到master分支，把写的原文件上传到新建的hexo分支 每次在另一台电脑上写博客前，先git pull将本地文件更新，而在写好文章后要记得用 123git add . git commit -m &quot;&quot;git push 参考了知乎上的一篇答案，十分详细，对新手小白十分友好，点击跳转 做完这个对git的分支功能有了更深刻的认识~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法总结整理]]></title>
    <url>%2FMarkdown-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[Markdown文本学习就不总结了 直接上传一个我觉得不错的链接吧 印象笔记Markdown文本入门指南 Markdown文本公式写法超全公式指南，简单易懂 hhh ，比如：$$E=mc^2$$ 然而用这个写法在Hexo Next主题下网页上并不会显示出公式，我查了一下 这个教程不错 打矩阵的时候你会发现无法多行显示，这个教程告诉了我们解决办法 Markdown代码块的使用方法1#include1 &lt;iostream&gt; 在句首加”” 即可，即键盘左上角123456789101112131415161718192021222324252627282930313233# Markdown引用的方法&gt; 引用内容引用方法在句首‘ &gt; ’加空格即可# 修改文字的颜色```html浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字：&lt;/font&gt;&lt;br /&gt; 深红色文字：&lt;font color=&quot;#660000&quot;&gt;深红色文字&lt;/font&gt;&lt;br /&gt; 浅绿色文字：&lt;font color=&quot;#00dd00&quot;&gt;浅绿色文字&lt;/font&gt;&lt;br /&gt; 深绿色文字：&lt;font color=&quot;#006600&quot;&gt;深绿色文字&lt;/font&gt;&lt;br /&gt; 浅蓝色文字：&lt;font color=&quot;#0000dd&quot;&gt;浅蓝色文字&lt;/font&gt;&lt;br /&gt; 深蓝色文字：&lt;font color=&quot;#000066&quot;&gt;深蓝色文字&lt;/font&gt;&lt;br /&gt; 浅黄色文字：&lt;font color=&quot;#dddd00&quot;&gt;浅黄色文字&lt;/font&gt;&lt;br /&gt; 深黄色文字：&lt;font color=&quot;#666600&quot;&gt;深黄色文字&lt;/font&gt;&lt;br /&gt; 浅青色文字：&lt;font color=&quot;#00dddd&quot;&gt;浅青色文字&lt;/font&gt;&lt;br /&gt; 深青色文字：&lt;font color=&quot;#006666&quot;&gt;深青色文字&lt;/font&gt;&lt;br /&gt; 浅紫色文字：&lt;font color=&quot;#dd00dd&quot;&gt;浅紫色文字&lt;/font&gt;&lt;br /&gt; 深紫色文字：&lt;font color=&quot;#660066&quot;&gt;深紫色文字&lt;/font&gt;&lt;br /&gt; 效果如下： 浅红色文字：浅红色文字： 深红色文字：深红色文字 浅绿色文字：浅绿色文字 深绿色文字：深绿色文字 浅蓝色文字：浅蓝色文字 深蓝色文字：深蓝色文字 浅黄色文字：浅黄色文字 深黄色文字：深黄色文字 浅青色文字：浅青色文字 深青色文字：深青色文字 浅紫色文字：浅紫色文字 深紫色文字：深紫色文字 修改字体大小123size为1：&lt;font size="1"&gt;size为1&lt;/font&gt;&lt;br /&gt; size为2：&lt;font size="2"&gt;size为2&lt;/font&gt;&lt;br /&gt; size为3：&lt;font size="3"&gt;size为3&lt;/font&gt;&lt;br /&gt; 效果如下： size为1：size为1size为2：size为2size为3：size为3 修改背景色1234&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色的设置是按照十六进制颜色值：#7FFFD4 背景色的设置是按照十六进制颜色值：#FF83FA 背景色的设置是按照十六进制颜色值：#D1EEEE 背景色的设置是按照十六进制颜色值：#C0FF3E]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I finally succeeded!]]></title>
    <url>%2FI-finally-succeeded.html</url>
    <content type="text"><![CDATA[It is really complicated. Fortunately, I get it. But I also have a long way to go… yes… It cost me three days to complete it. 我现在真的感觉好累好累啊 脖子痛，肌肉也紧张的很 呜呼 但也很满足啦 看到这几天自己的成果还是非常开心的~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
</search>
